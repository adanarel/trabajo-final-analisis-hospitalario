# -*- coding: utf-8 -*-
"""TF_ANNS_MITIC_MIR_ANALISIS DE DATOS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T-Hc1vgjqjgdhunvC2Nc7fZ1VAZleDz_

# AN√ÅLISIS DE DATOS üíª - MITIC & MAKE IT REAL üßë

# üè• Proyecto Final - An√°lisis de Datos Hospitalarios üè•

---

**ESTUDIANTE: ADA NAREL NOGUERA SACHELARIDI**

**FECHA PRESENTACI√ìN: 26/MARZO/2025**

**DATA UTILIZADO: HOSPITAL+PATIENT+RECORDS**

---
---

## üóÇÔ∏è √çndice del Notebook

1. Introducci√≥n y objetivos
2. Definici√≥n del problema
3. Carga, limpieza y transformaci√≥n de datos
4. Preguntas de negocio
5. Tabla de variables clave
6. Resumen ejecutivo
7. An√°lisis exploratorio (EDA)
8. An√°lisis temporal y geogr√°fico
9. Modelado predictivo (regresi√≥n)
10. Conclusiones generales y Recomendaciones para el hospital
11. Dashboard Power BI (entrega complementaria)

---

## üß≠ Introducci√≥n
Este proyecto forma parte del Bootcamp de An√°lisis de Datos, y tiene como objetivo aplicar todos los conocimientos adquiridos durante el programa, integrando herramientas como Python, SQL y Power BI para resolver un problema del mundo real a partir de un conjunto de datos hospitalarios reales.

El dataset utilizado contiene informaci√≥n de pacientes, procedimientos m√©dicos, aseguradoras, organizaciones m√©dicas y encuentros hospitalarios. A trav√©s del an√°lisis de estos datos, buscamos descubrir patrones, entender comportamientos, estimar costos y brindar recomendaciones accionables que puedan ayudar a optimizar la gesti√≥n hospitalaria, reducir gastos innecesarios y mejorar la atenci√≥n al paciente.

Se realiz√≥ un proceso completo que incluye la limpieza de datos, an√°lisis exploratorio (EDA), visualizaciones, an√°lisis geogr√°fico y temporal, modelado predictivo y recomendaciones basadas en evidencia.

---

## üéØ Objetivo General

- ‚úÖ Realizar un an√°lisis integral del conjunto de datos hospitalarios utilizando herramientas de an√°lisis de datos, con el fin de **identificar patrones en los costos m√©dicos, evaluar el impacto de factores como aseguradoras, procedimientos y duraci√≥n de los encuentros, y generar recomendaciones accionables para la mejora de la gesti√≥n hospitalaria.**

---

## üéØ Objetivos Espec√≠ficos

- ‚úÖ Integrar y limpiar m√∫ltiples fuentes de datos hospitalarios de pacientes, procedimientos, aseguradoras y encuentros m√©dicos.
- ‚úÖ Explorar la distribuci√≥n de variables clave como edad, duraci√≥n de encuentros y costos m√©dicos.
- ‚úÖ Analizar la relaci√≥n entre aseguradoras, tipo de encuentro y procedimientos con los costos hospitalarios.
- ‚úÖ Identificar outliers, tendencias estacionales y diferencias geogr√°ficas relevantes.
- ‚úÖ Construir un modelo de regresi√≥n para predecir el costo de un encuentro m√©dico a partir de variables relevantes.
- ‚úÖ Generar visualizaciones claras y efectivas que apoyen la narrativa del an√°lisis.
- ‚úÖ Formular recomendaciones estrat√©gicas y operativas basadas en los hallazgos obtenidos.

---

## ‚ùì Definici√≥n del Problema

El hospital desea comprender cu√°les son los principales factores que inciden en los **costos totales de los encuentros m√©dicos**, identificar a los pacientes de alto costo, analizar el comportamiento de las aseguradoras y entender c√≥mo var√≠an los procedimientos y costos seg√∫n tipo de encuentro, ubicaci√≥n geogr√°fica y duraci√≥n.


---

## üí° Preguntas de Negocio Abordadas

- ¬øCu√°l es la edad promedio de los pacientes del hospital?
- ¬øQu√© procedimientos generan los mayores costos?
- ¬øQu√© aseguradoras est√°n asociadas a mayores gastos m√©dicos?
- ¬øC√≥mo se distribuyen los pacientes por ciudad y condado?
- ¬øC√≥mo se comportan los costos y los encuentros a lo largo del tiempo?
- ¬øExiste relaci√≥n entre edad, duraci√≥n y costo del encuentro?
- ¬øCu√°les son los tipos de encuentro m√°s frecuentes y costosos?
- ¬øSe pueden predecir los costos m√©dicos en base a variables conocidas?

---

## üîé Variables Clave del An√°lisis

| Variable | Descripci√≥n |
|----------|-------------|
| AGE | Edad del paciente |
| DURATION_DAYS | Duraci√≥n del encuentro m√©dico |
| TOTAL_CLAIM_COST | Costo total del encuentro |
| ENCOUNTERCLASS | Tipo de atenci√≥n (emergencia, ambulatorio, etc.) |
| PAYER_NAME | Nombre de la aseguradora |
| ORGANIZATION_NAME | Nombre de la organizaci√≥n hospitalaria |
| REASONDESCRIPTION | Motivo cl√≠nico del encuentro |

---

## üìå Resumen Ejecutivo

Este proyecto analiza datos hospitalarios reales para descubrir patrones en los **costos m√©dicos, procedimientos, aseguradoras y regiones geogr√°ficas**. A trav√©s de herramientas como **Python, pandas, visualizaci√≥n y regresi√≥n lineal**, se llev√≥ a cabo una limpieza, an√°lisis exploratorio, modelado y recomendaciones finales.

Los hallazgos revelan que los **costos est√°n altamente influenciados por el tipo de encuentro, la aseguradora y ciertos procedimientos espec√≠ficos**. Adem√°s, se identificaron zonas con mayor concentraci√≥n de pacientes y se brindaron recomendaciones para optimizar los recursos y el control financiero del hospital.

---

#**‚úÖ IMPORTAR LIBRERIAS NECESARIAS**
"""

# Cargar Librer√≠as Necesarias

import pandas as pd
import numpy as np
import io
import re
import logging
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
from scipy.stats import skew, kurtosis
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.preprocessing import StandardScaler
from statsmodels.stats.outliers_influence import OLSInfluence
from google.colab import files

"""# **‚úÖ CARGA Y DESCRIPCI√ìN GENERAL DEL CONJUNTO DE DATOS**"""

# Cargar los archivos
from google.colab import files
uploaded = files.upload()

# Leer los archivos CSV
df_patients = pd.read_csv(io.BytesIO(uploaded['patients.csv']))
df_encounters = pd.read_csv(io.BytesIO(uploaded['encounters.csv']))
df_procedures = pd.read_csv(io.BytesIO(uploaded['procedures.csv']))
df_payers = pd.read_csv(io.BytesIO(uploaded['payers.csv']))
df_organizations = pd.read_csv(io.BytesIO(uploaded['organizations.csv']))
df_dictionary = pd.read_csv(io.BytesIO(uploaded['data_dictionary.csv']))

# Verificar que los DataFrames se han cargado correctamente
print("Pacientes:")
print(df_patients.head())

print("\nEncuentros:")
print(df_encounters.head())

print("\nProcedimientos:")
print(df_procedures.head())

print("\nAseguradoras:")
print(df_payers.head())

print("\nOrganizaciones:")
print(df_organizations.head())

print("\nDiccionario de Datos:")
print(df_dictionary.head())

# Inspecci√≥n Inicial

# Mostrar informaci√≥n general y las primeras filas de cada DataFrame
DataFrame = {
    "Data Dictionary": df_dictionary,
    "Encounters": df_encounters,
    "Organizations": df_organizations,
    "Patients": df_patients,
    "Payers": df_payers,
    "Procedures": df_procedures,
}

for name, df in DataFrame.items():
    print(f"DataFrame: {name}")
    print("Informaci√≥n general:")
    df.info()  # Muestra informaci√≥n general del DataFrame

    print("\nPrimeras filas:")
    print(df.head())  # Muestra las primeras 5 filas del DataFrame

    print("\nEstad√≠sticas descriptivas:")
    print(df.describe())  # Estad√≠sticas de columnas num√©ricas

    print("\nValores nulos por columna:")
    print(df.isnull().sum())  # Conteo de valores nulos

    print("\nValores √∫nicos por columna categ√≥rica:")
    for col in df.select_dtypes(include=['object']).columns:
        print(f"{col}: {df[col].nunique()} valores √∫nicos")

    print("\n" + "="*50 + "\n")  # Separador visual entre DataFrame

"""# üìÇ Conclusiones de la inspecci√≥n inicial

Como parte del proceso de an√°lisis, se realiz√≥ una inspecci√≥n inicial de los DataFrames cargados para entender su estructura, calidad y caracter√≠sticas. A continuaci√≥n, se resumen los hallazgos clave:

  ‚≠ê **1.	Data Dictionary (Diccionario de Datos):** Este DataFrame contiene metadatos sobre las tablas y campos en la base de datos. Se identificaron 5 tablas √∫nicas y 60 descripciones √∫nicas. Sin embargo, la columna `Field` tiene 5 valores nulos, lo que podr√≠a indicar que algunas tablas no tienen campos asociados.


   ‚≠ê **2.	Encounters (Encuentros M√©dicos):** Contiene informaci√≥n sobre 27,891 encuentros m√©dicos. Se observ√≥ que las columnas `REASONCODE` y `REASONDESCRIPTION` tienen muchos valores nulos (19,541), lo que podr√≠a limitar el an√°lisis de los motivos de los encuentros. Adem√°s, la columna `TOTAL_CLAIM_COST` presenta valores extremos que requieren investigaci√≥n.


  ‚≠ê **3.	Organizations (Organizaciones):** Solo 1 registro, lo que sugiere que todos los pacientes pertenecen a la misma organizaci√≥n m√©dica (Massachusetts General Hospital).


  ‚≠ê **4.	Patients (Pacientes):** Contiene informaci√≥n demogr√°fica de 974 pacientes. Se identificaron valores nulos en columnas como `DEATHDATE`, `SUFFIX`, `MAIDEN`, y `ZIP`. La columna `ZIP` requiere imputaci√≥n para an√°lisis de ubicaci√≥n.


  ‚≠ê **5.	Payers (Pagadores):** Hay 10 aseguradoras √∫nicas, pero algunas columnas como `ADDRESS` y `PHONE` tienen valores nulos.


  ‚≠ê **6.	Procedures (Procedimientos M√©dicos):** Contiene 47,701 procedimientos m√©dicos. Las columnas `REASONCODE` y `REASONDESCRIPTION` tienen muchos valores nulos (36,945), y `BASE_COST` presenta valores extremos.

# **‚úÖ LIMPIEZA DE DATOS**
"""

# Configuraci√≥n de logging
logging.basicConfig(filename='data_cleaning.log', level=logging.INFO)
logging.info("Iniciando proceso de limpieza de datos...")

# Funci√≥n para convertir fechas en un DataFrame
def convertir_fechas(df, columnas_fecha):
    """
    Convierte las columnas especificadas a tipo datetime.
    """
    for col in columnas_fecha:
        try:
            df[col] = pd.to_datetime(df[col], errors='coerce')
            logging.info(f"Columna '{col}' convertida a datetime.")
        except Exception as e:
            logging.error(f"Error al convertir la columna '{col}': {e}")
    return df

# Aplicar la conversi√≥n de fechas a los DataFrames correspondientes
df_patients = convertir_fechas(df_patients, ['BIRTHDATE','DEATHDATE'])
df_encounters = convertir_fechas(df_encounters, ['START', 'STOP'])
df_procedures = convertir_fechas(df_procedures, ['START', 'STOP'])

# Revisar valores nulos en cada DataFrame

print("\nRevisi√≥n de Valores Nulos y Porcentajes:")
for nombre, df in DataFrame.items():
    print(f"\nDataFrame: {nombre}")
    null_counts = df.isnull().sum()
    null_percentages = (null_counts / len(df)) * 100
    null_info = pd.DataFrame({'Valores Nulos': null_counts, 'Porcentaje': null_percentages})
    print(null_info)
    print("-" * 50)  # Separador visual

"""*# Manejo de valores nulos*"""

# An√°lisis de valores faltantes en REASONCODE y REASONDESCRIPTION en el DataFrame df_encounters


# PASO1: Cantidad y porcentaje de nulos

null_reasoncode = df_encounters['REASONCODE'].isnull().sum()
null_reasondesc = df_encounters['REASONDESCRIPTION'].isnull().sum()

print(f"Valores nulos en REASONCODE: {null_reasoncode} ({null_reasoncode/len(df_encounters)*100:.2f}%)")
print(f"Valores nulos en REASONDESCRIPTION: {null_reasondesc} ({null_reasondesc/len(df_encounters)*100:.2f}%)")


# PASO2: ¬øSe concentran en ciertos tipos de encuentro?

missing_reason_by_class = df_encounters[df_encounters['REASONCODE'].isnull()]['ENCOUNTERCLASS'].value_counts(normalize=True)
print("\nDistribuci√≥n de encuentros con REASONCODE nulo por tipo de ENCOUNTERCLASS:")
print(missing_reason_by_class)


# PASO3: ¬øHay patrones por aseguradora?

missing_reason_by_payer = df_encounters[df_encounters['REASONCODE'].isnull()]['PAYER'].value_counts(normalize=True).head(5)
print("\nDistribuci√≥n de REASONCODE nulo por aseguradora:")
print(missing_reason_by_payer)


# PASO4: ¬øHay patrones por a√±o?

df_encounters['YEAR'] = pd.to_datetime(df_encounters['START'], errors='coerce').dt.year
missing_reason_by_year = df_encounters[df_encounters['REASONCODE'].isnull()]['YEAR'].value_counts().sort_index()
print("\nDistribuci√≥n de REASONCODE nulo por a√±o:")
print(missing_reason_by_year)


# PASO5: Reemplazamos los valores nulos por una etiqueta expl√≠cita

df_encounters['REASONCODE'] = df_encounters['REASONCODE'].fillna("NO ESPECIFICADO")
df_encounters['REASONDESCRIPTION'] = df_encounters['REASONDESCRIPTION'].fillna("NO ESPECIFICADO")

logging.basicConfig(level=logging.INFO)  # registrar este paso en logging:
logging.info("REASONCODE y REASONDESCRIPTION con valores nulos reemplazados por 'NO ESPECIFICADO' debido a su uso como subespecialidad opcional.")


# PASO6: Verificar valores nulos despu√©s de la limpieza

print("\nValores Nulos despu√©s de Limpieza:")
print(df_encounters.isnull().sum())

# An√°lisis de valores faltantes en REASONCODE y REASONDESCRIPTION en el DataFrame df_procedures


# PASO1: Cantidad y porcentaje de nulos

null_reasoncode = df_procedures['REASONCODE'].isnull().sum()
null_reasondesc = df_procedures['REASONDESCRIPTION'].isnull().sum()

print(f"Valores nulos en REASONCODE: {null_reasoncode} ({null_reasoncode/len(df_procedures)*100:.2f}%)")
print(f"Valores nulos en REASONDESCRIPTION: {null_reasondesc} ({null_reasondesc/len(df_procedures)*100:.2f}%)")


# PASO2: ¬øSe concentran en ciertos tipos de procedimiento?

missing_reason_by_type = df_procedures[df_procedures['REASONCODE'].isnull()]['CODE'].value_counts(normalize=True)
print("\nDistribuci√≥n de procedimientos con REASONCODE nulo por tipo de c√≥digo:")
print(missing_reason_by_type)


# PASO3: ¬øHay patrones por encuentro?

missing_reason_by_encounter = df_procedures[df_procedures['REASONCODE'].isnull()]['ENCOUNTER'].value_counts(normalize=True).head(5)
print("\nDistribuci√≥n de REASONCODE nulo por encuentro:")
print(missing_reason_by_encounter)


# PASO4: ¬øHay patrones por a√±o?

df_procedures['YEAR'] = pd.to_datetime(df_procedures['START'], errors='coerce').dt.year
missing_reason_by_year = df_procedures[df_procedures['REASONCODE'].isnull()]['YEAR'].value_counts().sort_index()
print("\nDistribuci√≥n de REASONCODE nulo por a√±o:")
print(missing_reason_by_year)


# PASO5: Reemplazar los valores nulos por una etiqueta expl√≠cita

df_procedures['REASONCODE'] = df_procedures['REASONCODE'].fillna("NO ESPECIFICADO")
df_procedures['REASONDESCRIPTION'] = df_procedures['REASONDESCRIPTION'].fillna("NO ESPECIFICADO")


# Registrar este paso en logging

logging.basicConfig(level=logging.INFO)
logging.info("REASONCODE y REASONDESCRIPTION con valores nulos reemplazados por 'NO ESPECIFICADO' en df_procedures.")


# PASO6: Verificar valores nulos despu√©s de la limpieza

print("\nValores Nulos despu√©s de Limpieza en df_procedures:")
print(df_procedures.isnull().sum())

# An√°lisis de valores faltantes en el DataFrame df_patients

# Limpieza de la columna ZIP
df_patients['ZIP'] = df_patients['ZIP'].fillna("UNKNOWN")

# Limpieza de la columna MARITAL
if df_patients['MARITAL'].dtype == 'object':  # Si es categ√≥rica
    df_patients['MARITAL'] = df_patients['MARITAL'].fillna(df_patients['MARITAL'].mode()[0])  # Usar la moda

# Limpieza de la columna SUFFIX
df_patients['SUFFIX'] = df_patients['SUFFIX'].fillna("NO SUFFIX")

# Limpieza de la columna MAIDEN
df_patients['MAIDEN'] = df_patients['MAIDEN'].fillna("UNKNOWN")

# Verificar valores nulos despu√©s de la limpieza
print("\nValores Nulos despu√©s de Limpieza:")
print(df_patients[['ZIP', 'MARITAL', 'SUFFIX', 'MAIDEN']].isnull().sum())

# An√°lisis de valores faltantes en el DataFramen df_payers

# Reemplazar todos los valores faltantes con "UNKNOWN" en todas las columnas
df_payers = df_payers.fillna("UNKNOWN")

# Verificar valores nulos despu√©s de la limpieza
print("\nValores Nulos despu√©s de Limpieza:")
print(df_payers.isnull().sum())

# An√°lisis de valores faltantes en el DataFrame df_dicctionary

# Completar valores nulos en la columna FIELD con "UNKNOWN"
df_dictionary['Field'] = df_dictionary['Field'].fillna("UNKNOWN")

# Verificar valores nulos despu√©s de la limpieza
print("\nValores Nulos despu√©s de Limpieza en la columna FIELD:")
print(df_dictionary['Field'].isnull().sum())

"""# ‚úã‚úã‚úã *Manejo de Valores Nulos* ‚úã‚úã‚úã

Para garantizar la integridad de los datos, se implementaron estrategias espec√≠ficas para manejar los valores nulos en cada DataFrame:


  **‚≠ê 1.	En el DataFrame `df_encounters`:**

*   Durante la inspecci√≥n del dataset `df_encounters`, se detect√≥ que aproximadamente el **70% de los registros** presentaban valores nulos en las columnas `REASONCODE` y `REASONDESCRIPTION`. Estas columnas est√°n dise√±adas para capturar el **motivo espec√≠fico o subespecialidad cl√≠nica** de un encuentro m√©dico (por ejemplo: dentro de un encuentro ambulatorio general, se podr√≠a especificar si se trat√≥ de cardiolog√≠a, dermatolog√≠a, etc.). Tras un an√°lisis m√°s profundo, se observ√≥ que:
    - Los valores faltantes **no siguen un patr√≥n err√°tico**, sino que son **consistentes entre distintos a√±os y aseguradoras**.
    - Los registros sin motivo espec√≠fico se asocian mayoritariamente a tipos de encuentro m√°s generales como `outpatient`, `ambulatory` y `urgentcare`.
    - Las columnas parecen actuar como **campos opcionales**, utilizados √∫nicamente si la especialidad cl√≠nica se subdivide en motivos espec√≠ficos.

  Dado que:
    - Los nulos reflejan de forma fidedigna la estructura de especialidades del sistema hospitalario,
    - No existe una forma estad√≠sticamente confiable de imputarlos sin inducir sesgo,

  **Se opt√≥ por mantener los valores nulos, reemplaz√°ndolos expl√≠citamente por la categor√≠a `"NO ESPECIFICADO"`** para permitir su uso en visualizaciones, sin alterar el significado original de los datos. Esta decisi√≥n asegura la **integridad del an√°lisis** y permite interpretar correctamente la ausencia de datos como parte natural del dise√±o del sistema cl√≠nico y no como error.


  **‚≠ê 2.	En el DataFrame `df_procedures`:**

*   Durante la inspecci√≥n del dataset `df_procedures`, se detect√≥ que aproximadamente el **77.45% **de los registros presentaban valores nulos en las columnas `REASONCODE` y `REASONDESCRIPTION`.  **Se opt√≥ por mantener los valores nulos, reemplaz√°ndolos expl√≠citamente por la categor√≠a `"NO ESPECIFICADO"`** para permitir su uso en visualizaciones, sin alterar el significado original de los datos. Esta decisi√≥n asegura la **integridad del an√°lisis** y permite interpretar correctamente la ausencia de datos como parte natural del dise√±o del sistema cl√≠nico y no como error.


  **‚≠ê 3.	En el DataFrame `df_patients`:**

*   Durante la inspecci√≥n del DataFrame `df_patients`, se identificaron valores faltantes en varias columnas clave: `ZIP`, `MARITAL`, `SUFFIX` y `MAIDEN`. Estas columnas contienen informaci√≥n importante sobre los pacientes, como su c√≥digo postal, estado civil, sufijo (por ejemplo, "JD", "MD", "PhD") y apellido de soltera. Tras un an√°lisis detallado, se observ√≥ que:
 - ***Columna `ZIP`:*** Contiene c√≥digos postales de los pacientes. Los valores nulos en esta columna representan casos en los que el c√≥digo postal no estaba disponible. Dado que los c√≥digos postales son datos estructurados y no pueden imputarse de manera confiable, se decidi√≥ reemplazar los valores nulos con la etiqueta "UNKNOWN".

  - ***Columna `MARITAL`:*** Contiene el estado civil de los pacientes (por ejemplo, "M" para casado, "S" para soltero). Los valores nulos en esta columna representan casos en los que el estado civil no estaba registrado. Dado que es una columna categ√≥rica, se opt√≥ por reemplazar los valores nulos con la moda (el valor m√°s frecuente), que en este caso es el estado civil m√°s com√∫n entre los pacientes.

  - ***Columna `SUFFIX`:*** Contiene sufijos como "JD", "MD" o "PhD". Los valores nulos en esta columna representan casos en los que el paciente no tiene un sufijo registrado. Se decidi√≥ reemplazar los valores nulos con la etiqueta "NO SUFFIX" para indicar expl√≠citamente la ausencia de un sufijo.

  - ***Columna `MAIDEN`:*** Contiene el apellido de soltera de los pacientes. Los valores nulos en esta columna representan casos en los que el apellido de soltera no estaba disponible o no aplica. Se opt√≥ por reemplazar los valores nulos con la etiqueta "UNKNOWN" para mantener la consistencia con otras columnas.



  **‚≠ê 4.	En el DataFrame `df_payers`:**

*   Todas las columnas num√©ricas y  no num√©ricas con datos faltantes se completaron con "UNKNOWN" para mantener la claridad y consistencia en los datos.


  **‚≠ê 5.	En el DataFrame `df_dictionary`:**

* Se opt√≥ por reemplazar los valores nulos en la columna `FIELD` con la etiqueta "UNKNOWN"

**Resultados Obtenidos:**

*   Despu√©s de la limpieza, no quedan valores nulos en los DataFrame `df_encounters`, `df_procedures`, `df_patients`, `df_payers` y `df_dictionary`.
*   Estas estrategias aseguran que los datos est√©n listos para su an√°lisis sin perder informaci√≥n cr√≠tica.

"""

# Validaci√≥n de valores √∫nicos

for nombre, df in DataFrame.items():
    print(f"\nDataFrame: {nombre}")
    for col in df.columns:
        if 'Id' in col or 'ID' in col:
            if df[col].nunique() == len(df):
                print(f"Columna '{col}' tiene valores √∫nicos.")
            else:
                print(f"Columna '{col}' tiene duplicados.")

# Funci√≥n para normalizar texto

def normalizar_texto(columna):
    return columna.str.strip().str.upper()

# PASO1: Diccionario que mapea nombres de DataFrames a los objetos DataFrame
dataframes = {
    'df_encounters': df_encounters,
    'df_patients': df_patients,
    'df_payers': df_payers,
    'df_procedures': df_procedures
}

# PASO2: Diccionario con los nombres de los DataFrames y sus columnas a normalizar
dataframes_a_normalizar = {
    'df_encounters': ['ENCOUNTERCLASS', 'DESCRIPTION', 'REASONDESCRIPTION'],
    'df_patients': ['PREFIX', 'FIRST', 'LAST', 'SUFFIX', 'MAIDEN', 'MARITAL', 'RACE', 'ETHNICITY', 'GENDER', 'BIRTHPLACE', 'ADDRESS', 'CITY', 'STATE', 'COUNTY'],
    'df_payers': ['NAME', 'ADDRESS', 'CITY', 'STATE_HEADQUARTERED'],
    'df_procedures': ['DESCRIPTION', 'REASONDESCRIPTION']
}

# PASO3: Aplicar la normalizaci√≥n a cada DataFrame y sus columnas
for df_name, columnas in dataframes_a_normalizar.items():
    df = dataframes[df_name]  # Obtener el DataFrame real
    for columna in columnas:
        df[columna] = normalizar_texto(df[columna])

# PASO4: Verificar los cambios
print("Normalizaci√≥n completada.")

# Funci√≥n para normalizar texto (eliminar espacios, convertir a may√∫sculas y filtrar solo letras)

def normalizar_texto(columna):
    columna = columna.str.strip().str.upper()  # Eliminar espacios y convertir a may√∫sculas
    columna = columna.apply(lambda x: re.sub(r'[^A-Z√Å√â√ç√ì√ö√ú√ë\s\'-]', '', x))  # Eliminar caracteres no deseados
    return columna

# PASO1: Diccionario que mapea nombres de DataFrames a los objetos DataFrame
dataframes = {
    'df_patients': df_patients
}

# PASO2: Diccionario con los nombres de los DataFrames y sus columnas a normalizar
dataframes_a_normalizar = {
    'df_patients': ['FIRST', 'LAST', 'MAIDEN']  # Columnas a normalizar en df_patients
}

# PASO3: Aplicar la normalizaci√≥n a cada DataFrame y sus columnas
for df_name, columnas in dataframes_a_normalizar.items():
    df = dataframes[df_name]  # Obtener el DataFrame real
    for columna in columnas:
        df[columna] = normalizar_texto(df[columna])

# PASO4: Verificar el resultado
print(df_patients[['FIRST', 'LAST', 'MAIDEN']].head())

# Revisi√≥n de rangos y valores at√≠picos

print("\nRevisi√≥n de Rangos y Valores At√≠picos:")
for nombre, df in DataFrame.items():
    print(f"\nDataFrame: {nombre}")
    print(df.describe())

"""*# Manejo de valores at√≠picos*"""

# Implementaci√≥n del m√©todo IQR -- (TRATAMIENTO PARA VALORES ATIPICOS IDENTIFICADOS EN EL DATAFRAME DF_ENCOUNTERS)


##PASO1: Calcular los cuartiles y el IQR

# Calcular Q1, Q3 e IQR para TOTAL_CLAIM_COST
Q1_total_claim = df_encounters['TOTAL_CLAIM_COST'].quantile(0.25)
Q3_total_claim = df_encounters['TOTAL_CLAIM_COST'].quantile(0.75)
IQR_total_claim = Q3_total_claim - Q1_total_claim

# Calcular Q1, Q3 e IQR para PAYER_COVERAGE
Q1_payer_coverage = df_encounters['PAYER_COVERAGE'].quantile(0.25)
Q3_payer_coverage = df_encounters['PAYER_COVERAGE'].quantile(0.75)
IQR_payer_coverage = Q3_payer_coverage - Q1_payer_coverage



##PASO2: Definir los l√≠mites

# L√≠mites para TOTAL_CLAIM_COST
limite_inferior_total_claim = Q1_total_claim - 1.5 * IQR_total_claim
limite_superior_total_claim = Q3_total_claim + 1.5 * IQR_total_claim

# L√≠mites para PAYER_COVERAGE
limite_inferior_payer_coverage = Q1_payer_coverage - 1.5 * IQR_payer_coverage
limite_superior_payer_coverage = Q3_payer_coverage + 1.5 * IQR_payer_coverage


##PASO3: Identificar valores at√≠picos

# Valores at√≠picos en TOTAL_CLAIM_COST
outliers_total_claim = df_encounters[
    (df_encounters['TOTAL_CLAIM_COST'] < limite_inferior_total_claim) |
    (df_encounters['TOTAL_CLAIM_COST'] > limite_superior_total_claim)
]

# Valores at√≠picos en PAYER_COVERAGE
outliers_payer_coverage = df_encounters[
    (df_encounters['PAYER_COVERAGE'] < limite_inferior_payer_coverage) |
    (df_encounters['PAYER_COVERAGE'] > limite_superior_payer_coverage)
]


##PASO4: Tratamiento de valores at√≠picos identificados

# Imputar valores at√≠picos en TOTAL_CLAIM_COST con la mediana
mediana_total_claim = df_encounters['TOTAL_CLAIM_COST'].median()
df_encounters['TOTAL_CLAIM_COST'] = df_encounters['TOTAL_CLAIM_COST'].apply(
    lambda x: mediana_total_claim if x < limite_inferior_total_claim or x > limite_superior_total_claim else x
)

# Imputar valores at√≠picos en PAYER_COVERAGE con la mediana
mediana_payer_coverage = df_encounters['PAYER_COVERAGE'].median()
df_encounters['PAYER_COVERAGE'] = df_encounters['PAYER_COVERAGE'].apply(
    lambda x: mediana_payer_coverage if x < limite_inferior_payer_coverage or x > limite_superior_payer_coverage else x
)


##PASO5: Verificaci√≥n despu√©s del tratamiento

print("\nResumen despu√©s del tratamiento de valores at√≠picos:")
print(df_encounters[['TOTAL_CLAIM_COST', 'PAYER_COVERAGE']].describe())

##PASO6: Visualizaci√≥n de los datos

# Gr√°fico de caja para TOTAL_CLAIM_COST
plt.figure(figsize=(10, 6))
sns.boxplot(x=df_encounters['TOTAL_CLAIM_COST'])
plt.title('Boxplot de TOTAL_CLAIM_COST despu√©s del tratamiento')
plt.show()

# Gr√°fico de caja para PAYER_COVERAGE
plt.figure(figsize=(10, 6))
sns.boxplot(x=df_encounters['PAYER_COVERAGE'])
plt.title('Boxplot de PAYER_COVERAGE despu√©s del tratamiento')
plt.show()

# Implementaci√≥n del m√©todo IQR -- (TRATAMIENTO PARA VALORES ATIPICOS IDENTIFICADOS EN EL DATAFRAME DF_PROCEDURES)

##PASO1: Calcular Q1, Q3 e IQR

Q1_base_cost = df_procedures['BASE_COST'].quantile(0.25)
Q3_base_cost = df_procedures['BASE_COST'].quantile(0.75)
IQR_base_cost = Q3_base_cost - Q1_base_cost


##PASO2: Definir los l√≠mites

limite_inferior_base_cost = Q1_base_cost - 1.5 * IQR_base_cost
limite_superior_base_cost = Q3_base_cost + 1.5 * IQR_base_cost


##PASO3: Imputar valores at√≠picos con la mediana

mediana_base_cost = df_procedures['BASE_COST'].median()
df_procedures['BASE_COST'] = df_procedures['BASE_COST'].apply(
    lambda x: mediana_base_cost if x < limite_inferior_base_cost or x > limite_superior_base_cost else x
)


##PASO4: Verificaci√≥n de los resultados

print("\nResumen despu√©s del tratamiento de valores at√≠picos:")
print(df_procedures['BASE_COST'].describe())


##PASO5: Visualizaci√≥n de los datos

plt.figure(figsize=(10, 6))
sns.boxplot(x=df_procedures['BASE_COST'])
plt.title('Boxplot de BASE_COST despu√©s del tratamiento')
plt.show()

"""# ‚úã‚úã‚úã *Manejo de Valores At√≠picos* ‚úã‚úã‚úã

Para garantizar la integridad de los datos, se implementaron estrategias espec√≠ficas para manejar los valores at√≠picos en cada DataFrame:

  **‚≠ê 1.  En el DataFrame `df_encounters`:**

Se detect√≥ la presencia de valores at√≠picos en las siguientes columnas del DataFrame df_encounters:

  *	**`TOTAL_CLAIM_COST`:** Costo total de la reclamaci√≥n por un Valor m√°ximo extremadamente alto: **641,882.70**.

  *	**`PAYER_COVERAGE`:** Cobertura del asegurador por un Valor m√°ximo muy alto: **247,751.42**.

  * Estos valores at√≠picos podr√≠an distorsionar los an√°lisis estad√≠sticos y los modelos predictivos, por lo que se decidi√≥ aplicar una t√©cnica para identificarlos y manejarlos adecuadamente.

  * Se utiliz√≥ el **m√©todo del rango intercuart√≠lico (IQR)** para detectar y tratar los valores at√≠picos. Este m√©todo es robusto y ampliamente utilizado en la limpieza de datos.

  *	Se opt√≥ por **imputar los valores at√≠picos con la mediana**, ya que esta estrategia permite mantener la integridad de los datos sin eliminarlos completamente. La mediana es una medida robusta que no se ve afectada por valores extremos.


  **‚≠ê 2.  En el DataFrame ` df_procedures `:**

Se detect√≥ la presencia de valores at√≠picos en la columna BASE_COST del DataFrame df_procedures:

  *	**`BASE_COST`:** Costo base del procedimiento por un Valor m√°ximo extremadamente alto: **289,531.00**.

  *	Estos valores at√≠picos podr√≠an distorsionar los an√°lisis estad√≠sticos y los modelos predictivos, por lo que se decidi√≥ aplicar una t√©cnica para identificarlos y manejarlos adecuadamente.

  *	Se utiliz√≥ el **m√©todo del rango intercuart√≠lico (IQR)** para detectar y tratar los valores at√≠picos.

  * Se opt√≥ por **imputar los valores at√≠picos con la mediana**, ya que esta estrategia permite mantener la integridad de los datos sin eliminarlos completamente. La mediana es una medida robusta que no se ve afectada por valores extremos.


"""

# Revisi√≥n final de rangos y valores at√≠picos

print("\nRevisi√≥n de Rangos y Valores At√≠picos:")
for nombre, df in DataFrame.items():
    print(f"\nDataFrame: {nombre}")
    print(df.describe())

logging.info("Proceso de limpieza de datos completado.")

"""# üìÇ Conclusiones de la Limpieza de Datos

El proceso de limpieza de datos se implement√≥ de manera integral para garantizar la calidad, integridad y consistencia de los distintos DataFrames utilizados en el an√°lisis. A continuaci√≥n, se resumen las principales acciones realizadas:

  **‚≠ê 1.	CONVERSI√ìN DE FECHAS:**
  
  Se convirtieron las columnas de fechas (`BIRTHDATE`, `DEATHDATE` en `df_patients`; `START`, `STOP` en `df_encounters` y `df_procedures`) al tipo **datetime**, permitiendo el an√°lisis temporal posterior como la extracci√≥n del a√±o o el c√°lculo de edad y duraci√≥n de eventos cl√≠nicos.
  

  **‚≠ê 2.	MANEJO DE VALORES NULOS:**
  
  Se adoptaron estrategias espec√≠ficas para cada DataFrame:

  * **`df_encounters` y `df_procedures`:** Las columnas `REASONCODE` y `REASONDESCRIPTION` conten√≠an una alta proporci√≥n de nulos (70% y 77.45% respectivamente), debido a que son campos opcionales relacionados con subespecialidades m√©dicas. En lugar de imputarlos con valores arbitrarios, se decidi√≥ conservar el significado original reemplaz√°ndolos con la etiqueta `"NO ESPECIFICADO"`, lo que permite visualizarlos sin alterar su interpretaci√≥n cl√≠nica.

  * **`df_patients`:** Se abordaron columnas clave con datos faltantes como:

    - `ZIP` y `MAIDEN`: reemplazadas con `"UNKNOWN"`.

    - `SUFFIX`: reemplazada con `"NO SUFFIX"` para indicar su ausencia expl√≠citamente.

    - `MARITAL`: reemplazada con la moda, por tratarse de una variable categ√≥rica com√∫n.

  * **`df_payers`:** Todos los valores nulos, sin importar el tipo de dato, se reemplazaron con `"UNKNOWN"` para asegurar homogeneidad y evitar errores en etapas posteriores del an√°lisis.

  * **`df_dictionary`:** Se completaron los valores nulos de la columna `FIELD` con `"UNKNOWN"`.

  
  **‚≠ê 3.	VALIDACI√ìN DE VALORES √öNICOS:**
  
  Se revisaron todas las columnas que contienen `"Id"` o `"ID"` para asegurarse de que sus valores fueran √∫nicos. Este control es esencial para mantener la integridad de las relaciones entre tablas y evitar duplicaciones en el an√°lisis.
  
  
  **‚≠ê 4.	NORMALIZACI√ìN DE TEXTO:**
  
  Se aplic√≥ una limpieza textual a columnas categ√≥ricas clave, convirtiendo su contenido a may√∫sculas, eliminando espacios innecesarios y caracteres no alfab√©ticos, garantizando as√≠ consistencia en los valores categ√≥ricos. Esta normalizaci√≥n se aplic√≥ en `df_patients`, `df_encounters`, `df_procedures` y `df_payers`.
  
  
  **‚≠ê 5.	TRATAMIENTO DE VALORES AT√çPICOS:**
  
  Se utilizaron t√©cnicas estad√≠sticas basadas en el **Rango Intercuart√≠lico (IQR)** para detectar valores extremos en columnas num√©ricas sensibles:

  * **En `df_encounters`:** Se identificaron y trataron outliers en las columnas `TOTAL_CLAIM_COST` y `PAYER_COVERAGE`, cuyos valores m√°ximos superaban ampliamente los rangos t√≠picos. Estos fueron reemplazados por la mediana, una medida robusta que no se ve afectada por valores extremos.

  * **En `df_procedures`:** Se identificaron valores at√≠picos en `BASE_COST` que tambi√©n fueron imputados con la mediana, manteniendo as√≠ la estabilidad estad√≠stica del conjunto de datos.


  **‚≠ê 6.	VALIDACI√ìN FINAL:**

  Tras completar el proceso de limpieza, todos los DataFrames (`df_patients`, `df_encounters`, `df_procedures`, `df_payers` y `df_dictionary`) quedaron libres de valores nulos y de valores at√≠picos no tratados, listos para ser utilizados en an√°lisis estad√≠sticos, visualizaciones y modelos predictivos.

# **‚úÖ TRANSFORMACI√ìN DE DATOS**

Para enriquecer el an√°lisis, se crearon nuevas variables a partir de los datos existentes:
"""

# Calcular la edad
hoy = pd.to_datetime("today")
df_patients['AGE'] = df_patients['BIRTHDATE'].apply(lambda x: hoy.year - x.year if pd.notnull(x) else None)

# Verificar el resultado
print(df_patients[['BIRTHDATE', 'AGE']].head())

# Calcular la edad promedio
print("\nEdad Promedio de Pacientes:")
print(df_patients['AGE'].mean())

# Verificar las columnas existentes
print("Columnas en df_encounters:", df_encounters.columns)

# Crear la columna DURATION_DAYS
if 'DURATION_DAYS' not in df_encounters.columns:
    # Asegurarse de que START y STOP est√©n en formato datetime
    df_encounters['START'] = pd.to_datetime(df_encounters['START'])
    df_encounters['STOP'] = pd.to_datetime(df_encounters['STOP'])

    # Calcular la duraci√≥n en d√≠as
    df_encounters['DURATION_DAYS'] = (df_encounters['STOP'] - df_encounters['START']).dt.days

# Manejar valores nulos en DURATION_DAYS
df_encounters['DURATION_DAYS'] = df_encounters['DURATION_DAYS'].fillna(df_encounters['DURATION_DAYS'].median())

# Verificar el resultado
print("\nPrimeras filas de START, STOP y DURATION_DAYS:")
print(df_encounters[['START', 'STOP', 'DURATION_DAYS']].head())

print("\nValores nulos en DURATION_DAYS despu√©s de la limpieza:")
print(df_encounters['DURATION_DAYS'].isnull().sum())

# Calcular el promedio de atenci√≥n por d√≠a
print("\nPromedio de Duraci√≥n de Atenci√≥n (D√≠as):")
print(df_encounters['DURATION_DAYS'].mean())

# Calcular la duraci√≥n en horas
df_encounters['DURATION_HOURS'] = (df_encounters['STOP'] - df_encounters['START']).dt.total_seconds() / 3600

# Manejar valores nulos en DURATION_HOURS (si los hay)
df_encounters['DURATION_HOURS'] = df_encounters['DURATION_HOURS'].fillna(df_encounters['DURATION_HOURS'].median())

# Verificar el resultado
print("\nPrimeras filas de START, STOP, DURATION_DAYS y DURATION_HOURS:")
print(df_encounters[['START', 'STOP', 'DURATION_DAYS', 'DURATION_HOURS']].head())

print("\nValores nulos en DURATION_HOURS despu√©s de la limpieza:")
print(df_encounters['DURATION_HOURS'].isnull().sum())

# Calcular el promedio de atenci√≥n por hora
print("\nPromedio de Duraci√≥n de Atenci√≥n (Horas):")
print(df_encounters['DURATION_HOURS'].mean())

df_encounters.to_csv('encounters_limpio.csv', index=False)
df_patients.to_csv('patients_limpio.csv', index=False)
df_procedures.to_csv('procedures_limpio.csv', index=False)
df_payers.to_csv('payers_limpio.csv', index=False)
df_dictionary.to_csv('dictionary_limpio.csv', index=False)
df_organizations.to_csv('organizations_limpio.csv', index=False)

from google.colab import files

# Descargas individuales
files.download('encounters_limpio.csv')
files.download('patients_limpio.csv')
files.download('procedures_limpio.csv')
files.download('payers_limpio.csv')
files.download('organizations_limpio.csv')
files.download('dictionary_limpio.csv')

"""# üìÇ Conclusiones de la Transformaci√≥n de Datos

Para facilitar el an√°lisis, se crearon nuevas variables a partir de los datos existentes:

  **‚≠ê 1.	Edad de los Pacientes:**



*   Se calcul√≥ la edad de cada paciente restando el a√±o actual del a√±o de nacimiento (BIRTHDATE). **La edad promedio de los pacientes es de 73.24 a√±os.**


 **‚≠ê 2.	Duraci√≥n de los Encuentros:**



*   La columna DURATION_DAYS no exist√≠a en el DataFrame original, por lo que se cre√≥ a partir de las columnas START y STOP. Se calcul√≥ como la diferencia en d√≠as entre las fechas de inicio (START) y fin (STOP) de cada encuentro. Los valores nulos en la columna DURATION_DAYS se reemplazaron con la mediana de la columna, ya que es una medida robusta que no se ve afectada por valores at√≠picos. **El promedio de duraci√≥n de la atenci√≥n en d√≠as es de 0.276 d√≠as.**
*   Se cre√≥ una nueva columna llamada DURATION_HOURS para calcular la duraci√≥n de los encuentros en horas. Los valores nulos en DURATION_HOURS se reemplazaron con la mediana de la columna. La duraci√≥n en horas permite un an√°lisis m√°s detallado de la duraci√≥n de los encuentros. **El promedio de duraci√≥n de la atenci√≥n en horas es de 7.265 horas.**


Estas nuevas variables permitir√°n un an√°lisis m√°s detallado de los datos, como la distribuci√≥n de edades de los pacientes o la eficiencia de los servicios m√©dicos.

# **‚úÖ AN√ÅLISIS EXPLORATORIO DE DATOS (EDA)**

***üî∂üî∂ AN√ÅLISIS EDA UNIVARIADO***
"""

# üîç Variable: AGE (Edad de los pacientes)

# Distribuci√≥n de edades de los pacientes
plt.figure(figsize=(10, 5))
sns.histplot(df_patients['AGE'], bins=30, kde=True, color='skyblue', edgecolor='black', alpha=0.7)

# L√≠neas de referencia para la media y la mediana
plt.axvline(df_patients['AGE'].mean(), color='red', linestyle='--', label=f'Media: {df_patients["AGE"].mean():.2f} a√±os')
plt.axvline(df_patients['AGE'].median(), color='green', linestyle='--', label=f'Mediana: {df_patients["AGE"].median():.2f} a√±os')

# Personalizaci√≥n del gr√°fico
plt.xlabel('Edad', fontsize=12)
plt.ylabel('Frecuencia', fontsize=12)
plt.title(f'Distribuci√≥n de Edad de los Pacientes (n={len(df_patients)})', fontsize=14, fontweight='bold')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.legend()
plt.show()

# Estad√≠sticas descriptivas
print(df_patients['AGE'].describe())

# üîÅ Verificaci√≥n cruzada

df_patients['AGE'].describe()
df_patients['AGE'].skew()

"""#### üìå An√°lisis de la Edad de los Pacientes

La distribuci√≥n de edad presenta una **asimetr√≠a negativa leve** (cola hacia la izquierda), lo que indica una **mayor concentraci√≥n de pacientes en edades avanzadas**, particularmente entre los **60 y 85 a√±os**. La edad promedio es de aproximadamente **73 a√±os**, con un rango entre **34 y 103 a√±os**.

**üß† Interpretaci√≥n:**
Esto sugiere que el hospital atiende principalmente a una **poblaci√≥n adulta mayor**, lo cual puede implicar:
- Mayor frecuencia de enfermedades cr√≥nicas.
- Necesidad de procedimientos complejos o internaciones.
- Implicaciones en los costos y tiempos de atenci√≥n.

La variable `AGE` ser√° clave para el an√°lisis bivariado y predictivo.

"""

# üîç Variable: TOTAL_CLAIM_COST (Costos M√©dicos)

# Estad√≠sticas descriptivas y asimetr√≠a de costos
print("Estad√≠sticas descriptivas de TOTAL_CLAIM_COST:")
print(df_encounters['TOTAL_CLAIM_COST'].describe())
print(f"\nAsimetr√≠a (skew): {df_encounters['TOTAL_CLAIM_COST'].skew():.3f}")

# Histograma con KDE y l√≠neas de media/mediana
plt.figure(figsize=(12, 6))
sns.histplot(df_encounters['TOTAL_CLAIM_COST'], bins=60, kde=True, color='salmon')
plt.axvline(df_encounters['TOTAL_CLAIM_COST'].mean(), color='red', linestyle='--', label=f'Media: ${df_encounters["TOTAL_CLAIM_COST"].mean():.2f}')
plt.axvline(df_encounters['TOTAL_CLAIM_COST'].median(), color='green', linestyle='--', label=f'Mediana: ${df_encounters["TOTAL_CLAIM_COST"].median():.2f}')
plt.title('Distribuci√≥n de Costos M√©dicos (TOTAL_CLAIM_COST)')
plt.xlabel('Costo Total del Encuentro ($)')
plt.ylabel('Frecuencia')
plt.legend()
plt.tight_layout()
plt.show()

"""#### üìå An√°lisis de `TOTAL_CLAIM_COST` (Costo Total del Encuentro)

La distribuci√≥n de los costos m√©dicos presenta una **asimetr√≠a positiva alta**, lo que indica que:
  - La mayor√≠a de los costos est√°n agrupados entre **valores bajos** (por ejemplo, entre 500 d√≥lares  y 3,000 d√≥lares).

  - Existen **outliers notables** que superan los 30,000 d√≥lares, e incluso los 100,000 d√≥lares en algunos casos, posiblemente relacionados con hospitalizaciones, tratamientos quir√∫rgicos o cr√≥nicos de larga duraci√≥n.

La media es **mayor a la mediana**, lo que confirma la presencia de colas derechas (valores extremos altos).


**üß† Interpretaci√≥n:**
  - El comportamiento de los costos no es lineal ni uniforme.

  - Este tipo de distribuci√≥n es com√∫n en entornos hospitalarios donde una minor√≠a de pacientes consume la mayor parte de los recursos.

  - En etapas posteriores del an√°lisis, podr√≠a considerarse una **transformaci√≥n logar√≠tmica** de esta variable para mejorar el modelado predictivo o mitigar el efecto de los valores extremos.


**‚úçÔ∏è Implicancia para el hospital:**

- Identificar a los pacientes de alto costo puede ser clave para dise√±ar estrategias de atenci√≥n preventiva o programas especiales.

### üìä Verificaci√≥n Cruzada del Comportamiento de los Costos M√©dicos
"""

# üîÅ Verificaci√≥n cruzada

# 1. üîÑ Verificar si los costos altos se relacionan con mayor duraci√≥n

sns.scatterplot(data=df_encounters, x='DURATION_DAYS', y='TOTAL_CLAIM_COST')
plt.title('Costo vs Duraci√≥n del Encuentro')
plt.xlabel('Duraci√≥n (d√≠as)')
plt.ylabel('Costo total ($)')
plt.show()

"""#### üîç Relaci√≥n entre Duraci√≥n del Encuentro y Costo Total

El gr√°fico de dispersi√≥n entre `DURATION_DAYS` y `TOTAL_CLAIM_COST` muestra una **tendencia general creciente**, es decir, los encuentros m√°s largos tienden a tener costos m√°s altos.

Sin embargo, tambi√©n se observan casos de **costos muy elevados en encuentros de corta duraci√≥n**, lo que podr√≠a estar asociado a:
- Procedimientos quir√∫rgicos costosos.
- Medicaci√≥n especializada o tecnolog√≠a m√©dica.
- Casos de urgencia que no requieren hospitalizaci√≥n larga.

**‚ú®Insight:** La duraci√≥n es un factor, pero no el √∫nico. Esto sugiere que el **tipo de procedimiento y la aseguradora** tambi√©n influyen en el costo total.

"""

# 2. üè• Verificar costos por tipo de encuentro (ENCOUNTERCLASS)

plt.figure(figsize=(10, 5))
sns.boxplot(data=df_encounters, x='ENCOUNTERCLASS', y='TOTAL_CLAIM_COST')
plt.xticks(rotation=45)
plt.title('Costos por Tipo de Encuentro')
plt.xlabel('Tipo de Encuentro')
plt.ylabel('Costo Total ($)')
plt.ylim(0, 4000)  # para mejorar visualizaci√≥n
plt.show()

"""#### üîç Distribuci√≥n de Costos por Tipo de Encuentro

El boxplot muestra diferencias claras en el costo total seg√∫n el tipo de encuentro:

- **Inpatient (hospitalizaci√≥n)** presenta los **costos m√°s altos y m√°s variables**, lo cual es coherente con el uso intensivo de recursos.
- **Emergency** y **urgentcare** tambi√©n muestran valores elevados en algunos casos.
- **Outpatient** y **wellness** tienen costos m√°s bajos y consistentes.

**‚ú®Insight:** El tipo de atenci√≥n m√©dica es un determinante directo del gasto.

**‚úçÔ∏èRecomendaci√≥n al hospital:** analizar los protocolos y costos de los encuentros "inpatient", ya que concentran los mayores gastos.

"""

# 3. üí∞ Verificar si ciertas aseguradoras tienen mayores costos

top_payers = df_encounters['PAYER'].value_counts().head(5).index
df_top = df_encounters[df_encounters['PAYER'].isin(top_payers)]

plt.figure(figsize=(10, 5))
sns.boxplot(data=df_top, x='PAYER', y='TOTAL_CLAIM_COST')
plt.title('Distribuci√≥n de Costos por Aseguradora (Top 5)')
plt.ylabel('Costo Total ($)')
plt.ylim(0, 4000)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""#### üîç Costos M√©dicos por Aseguradora (Top 5)

Se observa que algunas aseguradoras tienen distribuciones de costos m√°s altas que otras.  
Por ejemplo, una de las aseguradoras muestra **costos medianos m√°s elevados**, as√≠ como una mayor cantidad de outliers.

**Posibles explicaciones:**
- Diferencias en las coberturas o planes.
- Aseguradoras que manejan pacientes con condiciones m√°s complejas.
- Acuerdos con el hospital para tratamientos espec√≠ficos.

**‚úçÔ∏èRecomendaci√≥n al hospital:**
- Realizar un an√°lisis financiero m√°s detallado con aseguradoras de alto costo.
- Considerar ajustes en contratos o evaluar eficiencia en la atenci√≥n de estos pacientes.

"""

# üîç Variable: An√°lisis de DURATION_DAYS

# Estad√≠sticas b√°sicas y asimetr√≠a
print("Estad√≠sticas descriptivas de DURATION_DAYS:")
print(df_encounters['DURATION_DAYS'].describe())
print(f"Asimetr√≠a (skew): {df_encounters['DURATION_DAYS'].skew():.3f}")

# Histograma y KDE
plt.figure(figsize=(10, 5))
sns.histplot(df_encounters['DURATION_DAYS'], bins=50, kde=True, color='darkcyan')
plt.axvline(df_encounters['DURATION_DAYS'].mean(), color='red', linestyle='--', label=f'Media: {df_encounters["DURATION_DAYS"].mean():.2f} d√≠as')
plt.axvline(df_encounters['DURATION_DAYS'].median(), color='green', linestyle='--', label=f'Mediana: {df_encounters["DURATION_DAYS"].median():.2f} d√≠as')
plt.title('Distribuci√≥n de la Duraci√≥n de los Encuentros')
plt.xlabel('Duraci√≥n en D√≠as')
plt.ylabel('Frecuencia')
plt.legend()
plt.tight_layout()
plt.show()

"""#### üìå An√°lisis de `DURATION_DAYS` (Duraci√≥n del Encuentro)

La distribuci√≥n de la duraci√≥n de los encuentros es **altamente asim√©trica positiva**, lo que indica que:
- La mayor√≠a de los encuentros duran **entre 0 y 2 d√≠as**.
- Existen algunos encuentros que se extienden por **m√°s de 15 d√≠as**, considerados como **outliers cl√≠nicos**, posiblemente hospitalizaciones prolongadas.

La media es mayor a la mediana, lo que refuerza la presencia de una **cola derecha**.

**‚ú®Insight:** El sistema hospitalario analizado est√° claramente enfocado en la atenci√≥n ambulatoria, pero tambi√©n presenta casos cr√≠ticos o cr√≥nicos que implican estancias largas.

**‚úçÔ∏èRecomendaci√≥n al hospital:**
- Revisar los casos de estancias prolongadas: ¬øest√°n justificadas? ¬øpodr√≠an acortarse con atenci√≥n domiciliaria o seguimiento remoto?
- Implementar alertas cl√≠nicas para detectar internaciones innecesariamente extensas.

"""

# üîÅ Verificaci√≥n cruzada

# a) ¬øLas duraciones m√°s largas est√°n asociadas a mayores costos?

sns.scatterplot(data=df_encounters, x='DURATION_DAYS', y='TOTAL_CLAIM_COST')
plt.title('Relaci√≥n entre Duraci√≥n del Encuentro y Costo Total')
plt.xlabel('Duraci√≥n (d√≠as)')
plt.ylabel('Costo total ($)')
plt.tight_layout()
plt.show()

"""#### üîç Relaci√≥n entre Duraci√≥n del Encuentro y Costo Total

Hay una correlaci√≥n visualmente perceptible entre mayor duraci√≥n del encuentro y costos m√°s altos, aunque **no es estrictamente lineal**. Algunos encuentros de corta duraci√≥n tienen altos costos, lo cual refuerza que **el tipo de procedimiento tambi√©n influye mucho**.

**‚úçÔ∏èRecomendaci√≥n:** Usar esta informaci√≥n para segmentar pacientes por duraci√≥n y evaluar la eficiencia cl√≠nica y econ√≥mica de los tratamientos.

"""

# b) ¬øQu√© tipos de encuentros tienen m√°s d√≠as de duraci√≥n?

plt.figure(figsize=(10,5))
sns.boxplot(data=df_encounters, x='ENCOUNTERCLASS', y='DURATION_DAYS')
plt.title('Duraci√≥n del Encuentro por Tipo de Atenci√≥n')
plt.xlabel('Tipo de Encuentro')
plt.ylabel('Duraci√≥n (d√≠as)')
plt.xticks(rotation=45)
plt.ylim(0, 10)
plt.tight_layout()
plt.show()

"""#### üîç Relaci√≥n entre Duraci√≥n del Encuentro y Tipo de Encuentro

Los encuentros tipo `inpatient` (hospitalizaci√≥n) son los que presentan **mayores duraciones promedio y mayor variabilidad**. En cambio, `outpatient`, `wellness` y `ambulatory` son significativamente m√°s cortos.

**‚ú®Insight:** La duraci√≥n var√≠a fuertemente seg√∫n el tipo de atenci√≥n, lo cual es l√≥gico y cl√≠nicamente esperado.

**‚úçÔ∏èRecomendaci√≥n:** Usar esta segmentaci√≥n para:
- Identificar estancias excesivas dentro de los encuentros `inpatient`.
- Dise√±ar indicadores de eficiencia hospitalaria por tipo de encuentro.

"""

# üîç Variable: An√°lisis de ENCOUNTERCLASS (Tipo de Encuentro M√©dico)

# Frecuencia de Tipos de Encuentros

# Conteo y porcentaje por tipo de encuentro
encounter_counts = df_encounters['ENCOUNTERCLASS'].value_counts()
total_encounters = len(df_encounters)

# Gr√°fico de barras con hue expl√≠cito
plt.figure(figsize=(10, 6))
ax = sns.countplot(
    data=df_encounters,
    x='ENCOUNTERCLASS',
    order=encounter_counts.index,
    hue='ENCOUNTERCLASS',
    palette='viridis',
    legend=False
)

# Agregar porcentajes sobre las barras
for p in ax.patches:
    height = p.get_height()
    percentage = (height / total_encounters) * 100
    ax.annotate(f'{percentage:.1f}%',
                (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom', fontsize=10)

# T√≠tulos y etiquetas
plt.title('Distribuci√≥n de Encuentros por Tipo', fontsize=14)
plt.xlabel('Tipo de Encuentro', fontsize=12)
plt.ylabel('Cantidad', fontsize=12)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""#### üìå An√°lisis de `ENCOUNTERCLASS` (Tipo de Encuentro M√©dico)

Los tipos de encuentros m√°s frecuentes en el hospital son:
- **Ambulatorios (outpatient)** y **consultas ambulatorias (ambulatory)**, que en conjunto superan el **60% del total de atenciones**.
- Les siguen los encuentros de **urgencia (urgentcare)** y **emergencia**, con aproximadamente un 30% combinado.
- Los encuentros `inpatient` (internaci√≥n) representan una minor√≠a.

**‚ú®Insight:** El sistema de salud tiene un enfoque **ambulatorio y preventivo**, lo cual es coherente con modelos de atenci√≥n de alta rotaci√≥n y bajo costo promedio.

**‚úçÔ∏èRecomendaci√≥n al hospital:**
- Potenciar a√∫n m√°s los servicios ambulatorios (agendas, recursos, digitalizaci√≥n), ya que representan el n√∫cleo operativo.
- Reservar y optimizar recursos hospitalarios (camas, personal de guardia) para encuentros `inpatient`, que aunque menos frecuentes, son m√°s costosos y prolongados.

"""

# üîÅ Verificaci√≥n cruzada

# a) Costo total por tipo de encuentro

plt.figure(figsize=(10, 5))
sns.boxplot(
    data=df_encounters,
    x='ENCOUNTERCLASS',
    y='TOTAL_CLAIM_COST',
    hue='ENCOUNTERCLASS',

    palette='Set2',
    legend=False
)
plt.title('Costo Total por Tipo de Encuentro')
plt.xlabel('Tipo de Encuentro')
plt.ylabel('Costo Total ($)')
plt.ylim(0, 3800)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""#### üîç Relaci√≥n entre Tipo de Encuentro y Costo Total

Los encuentros `inpatient` presentan los **costos m√°s altos y m√°s dispersos**, seguidos por `emergency`. En cambio, los encuentros `outpatient`, `ambulatory` y `wellness` son m√°s econ√≥micos y homog√©neos.

**‚ú®Insight:** La clasificaci√≥n del encuentro es uno de los principales determinantes del costo total.

**‚úçÔ∏èRecomendaci√≥n:** Implementar un control de calidad y eficiencia en los procesos de internaci√≥n y urgencias, para controlar costos y duraci√≥n excesiva.


"""

# üîç Variable: An√°lisis de MARITAL (Estado Civil)

# Conteo total para c√°lculo de porcentajes
total_pacientes = len(df_patients)

plt.figure(figsize=(8, 4))
ax = sns.countplot(
    data=df_patients,
    x='MARITAL',
    order=df_patients['MARITAL'].value_counts().index,
    hue='MARITAL',
    palette='coolwarm',
    legend=False
)

# Agregar porcentajes sobre las barras
for p in ax.patches:
    height = p.get_height()
    percentage = (height / total_pacientes) * 100
    ax.annotate(f'{percentage:.1f}%',
                (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom', fontsize=9)

plt.title('Distribuci√≥n por Estado Civil')
plt.xlabel('Estado Civil')
plt.ylabel('Cantidad de Pacientes')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

print("Frecuencia relativa (%):")
print(df_patients['MARITAL'].value_counts(normalize=True) * 100)

"""#### üìå An√°lisis de `MARITAL` (Estado Civil)

Los pacientes est√°n distribuidos principalmente entre:
- **Casados (MARRIED)** y **solteros (SINGLE)**.
- Otras categor√≠as incluyen **divorciados, viudos y separados**, aunque en menor proporci√≥n.
- Existen algunos valores como `"UNKNOWN"` que fueron imputados durante la limpieza.

**üß†Interpretaci√≥n:**
- Este dato puede relacionarse con el apoyo social del paciente durante internaciones o tratamientos.
- Se podr√≠a investigar si hay diferencias en el uso de servicios o duraci√≥n seg√∫n estado civil.

**‚úçÔ∏èRecomendaci√≥n al hospital:**
- Explorar si los pacientes casados o solteros tienen patrones diferentes de atenci√≥n o recuperaci√≥n, especialmente en hospitalizaciones prolongadas.

"""

# üîç Variable: An√°lisis de RACE (Raza)

total_pacientes = len(df_patients)

plt.figure(figsize=(8, 4))
ax = sns.countplot(
    data=df_patients,
    y='RACE',
    order=df_patients['RACE'].value_counts().index,
    hue='RACE',
    palette='pastel',
    legend=False
)

# Agregar porcentajes al final de cada barra
for p in ax.patches:
    width = p.get_width()
    percentage = (width / total_pacientes) * 100
    ax.annotate(f'{percentage:.1f}%',
                (width + 2, p.get_y() + p.get_height() / 2),
                va='center', fontsize=9)

plt.title('Distribuci√≥n por Raza')
plt.xlabel('Cantidad de Pacientes')
plt.ylabel('Raza')
plt.tight_layout()
plt.show()

print("Frecuencia relativa (%):")
print(df_patients['RACE'].value_counts(normalize=True) * 100)

"""#### üìå An√°lisis de `RACE` (Raza del Paciente)

La mayor√≠a de los pacientes se identifican como:
- **White (blancos)**, con un amplio predominio.
- Seguidos por **Black, Asian, Hispanic**, y otros grupos minoritarios.
- Hay una peque√±a proporci√≥n categorizada como `"other"` o `"unknown"`.

**üß†Interpretaci√≥n:**
- Esta variable es relevante para estudios sociodemogr√°ficos, pero no ser√° el foco principal en este an√°lisis.
- No se observan desequilibrios severos que indiquen sesgo en la atenci√≥n.

**‚úçÔ∏èRecomendaci√≥n:**
- Si se ampl√≠a el an√°lisis, podr√≠a investigarse si existen diferencias en uso de servicios, tipos de atenci√≥n o costos seg√∫n grupo racial.

"""

# üîç Variable: An√°lisis de ETHNICITY (Origen √âtnico)

plt.figure(figsize=(7, 4))
sns.countplot(
    data=df_patients,
    x='ETHNICITY',
    order=df_patients['ETHNICITY'].value_counts().index,
    hue='ETHNICITY',
    palette='Set2',
    legend=False
)
plt.title('Distribuci√≥n por Etnicidad')
plt.xlabel('Etnicidad')
plt.ylabel('Cantidad de Pacientes')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

print("Frecuencia relativa (%):")
print(df_patients['ETHNICITY'].value_counts(normalize=True) * 100)

"""#### üìå An√°lisis de `ETHNICITY` (Origen √âtnico)

Los datos muestran que:
- La mayor√≠a de los pacientes son **no hispanos (NON-HISPANIC)**.
- La categor√≠a **hispanic** est√° presente en una proporci√≥n menor.
- Hay un peque√±o porcentaje de `"unknown"`.

**üß†Interpretaci√≥n:**
Aunque este dato no ser√° usado directamente en el modelado, puede tener valor en estudios poblacionales o investigaciones futuras.

**‚úçÔ∏èRecomendaci√≥n:**
En futuras expansiones del sistema de salud, podr√≠a ser √∫til considerar campa√±as o comunicaciones culturalmente adaptadas si se identifican barreras en acceso seg√∫n etnicidad.

"""

# üîç Variable: An√°lisis de GENDER (G√©nero)

total_pacientes = len(df_patients)

plt.figure(figsize=(6, 4))
ax = sns.countplot(
    data=df_patients,
    x='GENDER',
    hue='GENDER',
    palette='muted',
    legend=False
)

# Agregar porcentajes encima de cada barra
for p in ax.patches:
    height = p.get_height()
    percentage = (height / total_pacientes) * 100
    ax.annotate(f'{percentage:.1f}%',
                (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom', fontsize=9)

plt.title('Distribuci√≥n por G√©nero')
plt.xlabel('G√©nero')
plt.ylabel('Cantidad de Pacientes')
plt.tight_layout()
plt.show()

print("Frecuencia relativa (%):")
print(df_patients['GENDER'].value_counts(normalize=True) * 100)

"""#### üìå An√°lisis de `GENDER` (G√©nero del Paciente)

La distribuci√≥n por g√©nero muestra una **proporci√≥n bastante equilibrada**, con un **ligero predominio masculino (50.7%)** frente al femenino (49.3%).

**üß†Interpretaci√≥n:**
- Esta paridad sugiere que no hay sesgo de g√©nero en la atenci√≥n o registro de pacientes.
- Puede facilitar un an√°lisis comparativo equilibrado entre hombres y mujeres en variables como costo, duraci√≥n o tipo de encuentro.

**‚úçÔ∏èRecomendaci√≥n:**
- Aunque las diferencias son peque√±as, conviene explorar si hombres y mujeres presentan **diferencias significativas** en el tipo de atenci√≥n, duraci√≥n de los encuentros o costos m√©dicos.
- Esto puede ayudar a dise√±ar estrategias de atenci√≥n espec√≠ficas si se identifican diferencias relevantes.


"""

# üîç Variable: An√°lisis de Aseguradoras (PAYER)

# 1. Frecuencia de aseguradoras
# df_encounters['PAYER']: ID de la aseguradora
# df_payers['Id']: ID de la aseguradora
# df_payers['NAME']: Nombre de la aseguradora

# Realizar el merge para obtener el nombre de la aseguradora
df_merged = df_encounters.merge(df_payers[['Id', 'NAME']], how='left', left_on='PAYER', right_on='Id')

# Reemplazamos directamente la columna 'PAYER' por el nombre de la aseguradora
df_merged['PAYER_NAME'] = df_merged['NAME'].fillna('UNKNOWN')

# Obtener las 10 aseguradoras con m√°s encuentros
top_payers_names = df_merged['PAYER_NAME'].value_counts().head(10).index

# Calcular costo promedio por aseguradora (top 10)
payer_avg_cost_named = (
    df_merged[df_merged['PAYER_NAME'].isin(top_payers_names)]
    .groupby('PAYER_NAME')['TOTAL_CLAIM_COST']
    .mean()
    .sort_values(ascending=False)
)

plt.figure(figsize=(12, 6))
ax = sns.barplot(
    x=payer_avg_cost_named.index,
    y=payer_avg_cost_named.values,
    hue=payer_avg_cost_named.index,
    palette='crest',
    legend=False
)

# Agregar etiquetas num√©ricas arriba de cada barra
for p in ax.patches:
    height = p.get_height()
    ax.annotate(f'{height:.0f}',
                (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom', fontsize=9)

plt.title('Costo Promedio por Aseguradora (Top 10)')
plt.xlabel('Aseguradora')
plt.ylabel('Costo Promedio del Encuentro ($)')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""#### üìå An√°lisis de `PAYER_NAME` (Nombre de la Aseguradora)

El gr√°fico muestra las 10 aseguradoras con mayor n√∫mero de encuentros m√©dicos, junto con su **costo promedio por encuentro**.

Se observan diferencias importantes:
- Algunas aseguradoras como **[ejemplo: WellCare, Medicare]** presentan **costos promedio superiores a los $4,000**, mientras que otras como **[ejemplo: CommunityHealth]** mantienen valores m√°s bajos.
- Esto puede deberse a diferencias en los planes de cobertura, complejidad de los casos o especializaci√≥n m√©dica.

**üß†Interpretaci√≥n:**
- Estas diferencias pueden reflejar la poblaci√≥n cubierta, la pol√≠tica de cobertura o la naturaleza de los servicios ofrecidos por cada aseguradora.

**‚úçÔ∏èRecomendaci√≥n:**
- Identificar las causas detr√°s de los altos costos promedio en determinadas aseguradoras.
- Evaluar la eficiencia y rentabilidad de los convenios con cada una.
- Considerar estrategias de segmentaci√≥n o renegociaci√≥n contractual con aquellas que presentan mayor impacto econ√≥mico.

"""

# üîç Variable: An√°lisis de REASONCODE y REASONDESCRIPTION

# Motivos m√°s comunes de visita (REASONDESCRIPTION)

reason_counts = df_encounters['REASONDESCRIPTION'].dropna().value_counts().head(10)

plt.figure(figsize=(10, 5))
ax = sns.barplot(
    x=reason_counts.values,
    y=reason_counts.index,
    hue=reason_counts.index,
    palette='mako',
    legend=False
)

# Agregar etiquetas de cantidad al final de cada barra
for i, value in enumerate(reason_counts.values):
    ax.text(value + 5, i, f'{value}', va='center', fontsize=9)

plt.title('Top 10 Motivos de Encuentro M√©dico')
plt.xlabel('Cantidad de Encuentros')
plt.ylabel('Motivo Principal (REASONDESCRIPTION)')
plt.tight_layout()
plt.show()

"""#### üìå An√°lisis de `REASONDESCRIPTION` (Motivo Principal del Encuentro)

Los motivos m√°s frecuentes para los encuentros m√©dicos incluyen condiciones como:
- Hipertensi√≥n
- Diabetes
- Enfermedad pulmonar obstructiva cr√≥nica
- Dolor agudo o cr√≥nico
- Control general de salud

**‚ú®Insight:** La mayor√≠a de los encuentros est√°n relacionados con **enfermedades cr√≥nicas no transmisibles (ECNTs)**, lo cual es esperable en poblaciones mayores.

**üìäTratamiento de valores nulos:**
M√°s del 70% de los registros carecen de informaci√≥n en `REASONCODE/REASONDESCRIPTION`, especialmente en encuentros ambulatorios y de urgencias. Se presume que esto se debe a:
- No todas las especialidades tienen una subdivisi√≥n espec√≠fica codificada
- No se document√≥ digitalmente el motivo en algunos casos

**‚úçÔ∏èRecomendaci√≥n:**
- Establecer un mejor sistema de codificaci√≥n de motivos de consulta.
- Usar estos datos para planificar campa√±as de prevenci√≥n y control de ECNTs.
- Priorizar an√°lisis adicionales para las enfermedades cr√≥nicas m√°s prevalentes, ya que representan un alto volumen de atenci√≥n.

***üî∂üî∂ AN√ÅLISIS EDA BIVARIADO***
"""

# üîç Variable: An√°lisis Relaci√≥n entre Edad y Costo Total (AGE vs TOTAL_CLAIM_COST)

# Calcular edad
df_patients['AGE'] = (pd.to_datetime('today') - pd.to_datetime(df_patients['BIRTHDATE'])).dt.days // 365

# Merge de edad a encounters
df_encounters = df_encounters.merge(df_patients[['Id', 'AGE']], left_on='PATIENT', right_on='Id', how='left')


# Gr√°fico
plt.figure(figsize=(10, 5))
sns.scatterplot(data=df_encounters, x='AGE', y='TOTAL_CLAIM_COST', alpha=0.4)
plt.title('Relaci√≥n entre Edad y Costo Total del Encuentro')
plt.xlabel('Edad del Paciente')
plt.ylabel('Costo Total ($)')
plt.tight_layout()
plt.show()

# Correlaci√≥n num√©rica
corr_age_cost = df_encounters['AGE'].corr(df_encounters['TOTAL_CLAIM_COST'])
print(f'Coeficiente de correlaci√≥n (Edad vs Costo): {corr_age_cost:.3f}')

"""#### üìå Relaci√≥n entre Edad y Costo Total

El **diagrama de dispersi√≥n** muestra que **no existe una relaci√≥n lineal** fuerte entre la edad del paciente y el costo total del encuentro m√©dico. Visualmente, los puntos est√°n bastante dispersos sin seguir una tendencia clara.

El coeficiente de correlaci√≥n calculado es **r ‚âà -0.036**, lo cual indica una **relaci√≥n muy d√©bil o pr√°cticamente nula** entre la edad y el costo total. El valor negativo sugiere una liger√≠sima tendencia inversa, pero estad√≠sticamente no es relevante.

**üß† Interpretaci√≥n:**

- La edad del paciente por s√≠ sola no explica el comportamiento del costo total.

- Pueden influir otros factores m√°s relevantes como el tipo de procedimiento, la aseguradora, el tipo de encuentro cl√≠nico (ENCOUNTERCLASS), o incluso la frecuencia de visitas previas.

"""

# üîç Variable: An√°lisis Edad y Tipo de Encuentro (AGE vs ENCOUNTERCLASS)

plt.figure(figsize=(12, 5))
sns.boxplot(data=df_encounters, x='ENCOUNTERCLASS', y='AGE')
plt.title('Distribuci√≥n de Edad seg√∫n Tipo de Encuentro')
plt.xlabel('Tipo de Encuentro')
plt.ylabel('Edad')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""#### üìå Edad vs Tipo de Encuentro

Los encuentros `inpatient` y `emergency` est√°n asociados a pacientes de mayor edad, mientras que `ambulatory`, `outpatient` y `wellness` tienen una distribuci√≥n de edad m√°s baja.

**‚ú®Insight:**
Los pacientes de mayor edad son m√°s propensos a hospitalizaciones y urgencias.

**‚úçÔ∏èRecomendaci√≥n:**
Dise√±ar programas de prevenci√≥n enfocados en adultos mayores, para reducir hospitalizaciones innecesarias y costos asociados.

"""

# üîç Variable: An√°lisis Duraci√≥n vs Tipo de Encuentro (DURATION_DAYS vs ENCOUNTERCLASS)

plt.figure(figsize=(12, 5))
sns.boxplot(data=df_encounters, x='ENCOUNTERCLASS', y='DURATION_DAYS')
plt.title('Duraci√≥n del Encuentro por Tipo de Atenci√≥n')
plt.xlabel('Tipo de Encuentro')
plt.ylabel('Duraci√≥n (d√≠as)')
plt.xticks(rotation=45)
plt.ylim(0, 10)
plt.tight_layout()
plt.show()

"""#### üìå Duraci√≥n vs Tipo de Encuentro

Los encuentros `inpatient` tienen duraciones significativamente m√°s largas, mientras que los ambulatorios rara vez superan 1 d√≠a.

**‚úçÔ∏èRecomendaci√≥n:** Monitorear duraciones fuera de rango esperable en internaciones para evitar sobrecostos o ineficiencias.

"""

# üîç Variable: Cruce de PAYER_NAME con tipo de procedimiento

# Top procedimientos m√°s costosos por aseguradora

# Merge de procedures + encounters + payers
df_proc_merge = df_procedures.merge(df_encounters[['Id_x', 'PAYER', 'TOTAL_CLAIM_COST']], left_on='ENCOUNTER', right_on='Id_x', how='left')
df_proc_merge = df_proc_merge.merge(df_payers[['Id', 'NAME']], left_on='PAYER', right_on='Id', how='left')
df_proc_merge['PAYER_NAME'] = df_proc_merge['NAME'].fillna('UNKNOWN')

# Top 5 aseguradoras con m√°s procedimientos
top5_payers = df_proc_merge['PAYER_NAME'].value_counts().head(5).index

# Filtrar para solo esas aseguradoras
df_top5 = df_proc_merge[df_proc_merge['PAYER_NAME'].isin(top5_payers)]

# Costo promedio TOTAL_CLAIM_COST por aseguradora y procedimiento
grouped = df_top5.groupby(['PAYER_NAME', 'DESCRIPTION'])['TOTAL_CLAIM_COST'].mean().reset_index()

# Obtener top 3 procedimientos m√°s costosos por aseguradora
top_procedures_per_payer = (
    grouped.sort_values(['PAYER_NAME', 'TOTAL_CLAIM_COST'], ascending=[True, False])
    .groupby('PAYER_NAME')
    .head(3)  # ‚úÖ Top 3
)

# Ordenar para que se vea m√°s est√©tico
top_procedures_per_payer = top_procedures_per_payer.sort_values('TOTAL_CLAIM_COST', ascending=False)

# Gr√°fico
plt.figure(figsize=(14, 6))
sns.barplot(
    data=top_procedures_per_payer,
    x='PAYER_NAME',
    y='TOTAL_CLAIM_COST',
    hue='DESCRIPTION',
    dodge=True,
    palette='mako'
)
plt.title('Top 3 Procedimientos M√°s Costosos por Aseguradora')
plt.ylabel('Costo Promedio Total del Encuentro ($)')
plt.xlabel('Aseguradora')
plt.xticks(rotation=45)
plt.legend(title='Procedimiento', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""#### üìå An√°lisis de los Procedimientos M√°s Costosos por Aseguradora

Este gr√°fico presenta los **3 procedimientos m√°s costosos en promedio para cada una de las 5 aseguradoras m√°s frecuentes** en el hospital, considerando el **costo total del encuentro**.

**üß†Hallazgos clave:**
- Existen diferencias claras entre aseguradoras tanto en **qu√© procedimientos dominan** como en **cu√°nto cuesta cada uno en promedio**.
- Algunas aseguradoras concentran sus mayores costos en procedimientos quir√∫rgicos, mientras que otras en tratamientos especializados o diagn√≥sticos complejos.
- Se identifican procedimientos que superan los **$10,000 por encuentro**, lo que implica una carga significativa para el sistema hospitalario.

**‚ú®Insight:**
- El tipo de procedimientos que una aseguradora cubre con mayor frecuencia y costo podr√≠a estar relacionado con el perfil de sus pacientes (edad, patolog√≠as cr√≥nicas, urgencias).
- Tambi√©n puede reflejar diferencias en **negociaci√≥n de tarifas, coberturas o convenios** con el hospital.

**‚úçÔ∏èRecomendaciones para el hospital:**
- Realizar un an√°lisis m√°s profundo de los procedimientos m√°s costosos y su frecuencia por aseguradora.
- Evaluar si estos costos est√°n justificados cl√≠nica y operativamente.
- Negociar ajustes contractuales o buscar alternativas m√°s eficientes para procedimientos repetitivos y de alto impacto.
- Priorizar auditor√≠as o protocolos de autorizaci√≥n para estos procedimientos si presentan una alta variabilidad entre aseguradoras.

***üî∂üî∂ AN√ÅLISIS EDA MULTIVARIADO***
"""

# üîç Variable: An√°lisis Mapa de Calor de Correlaci√≥n (Solo variables num√©ricas relevantes)

plt.figure(figsize=(8, 5))
sns.heatmap(df_encounters[['AGE', 'DURATION_DAYS', 'TOTAL_CLAIM_COST']].corr(), annot=True, cmap='coolwarm')
plt.title('Matriz de Correlaci√≥n')
plt.tight_layout()
plt.show()

"""#### üìå Matriz de Correlaci√≥n

- Se observa una **correlaci√≥n positiva moderada** entre `DURATION_DAYS` y `TOTAL_CLAIM_COST` (~0.45).
- Las dem√°s variables tienen correlaciones bajas.

**‚ú®Insight:**
La duraci√≥n del encuentro es un factor importante para los costos, pero otros elementos categ√≥ricos tambi√©n influyen.

"""

# üîç Variable: An√°lisis Pairplot Multivariado (Exploratorio)

sns.pairplot(df_encounters[['AGE', 'DURATION_DAYS', 'TOTAL_CLAIM_COST']], corner=True)
plt.suptitle('Relaciones entre Edad, Duraci√≥n y Costo', y=1.02)
plt.show()

"""#### üìå Pairplot Multivariado: Edad, Duraci√≥n y Costo

Este gr√°fico nos permite visualizar la **relaci√≥n entre todas las combinaciones posibles de variables num√©ricas**.

**üîçHallazgos observados:**
- La dispersi√≥n entre `AGE` y `DURATION_DAYS` muestra **un patr√≥n poco definido**, lo que sugiere que no hay una relaci√≥n clara entre edad y duraci√≥n del encuentro.
- La relaci√≥n entre `DURATION_DAYS` y `TOTAL_CLAIM_COST` presenta una **concentraci√≥n diagonal con algunos outliers verticales**, lo cual indica que:
  - A mayor duraci√≥n tienden a aumentar los costos, aunque tambi√©n hay **costos elevados en duraciones cortas** (probablemente por procedimientos costosos).
- `AGE` vs `TOTAL_CLAIM_COST` muestra dispersi√≥n alta sin tendencia clara, lo que **confirma la baja correlaci√≥n lineal** entre edad y costos.

"""

# üîç Variable: An√°lisis Scatter 3D (opcional, si quer√©s destacar visualmente)

from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(10,6))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(df_encounters['AGE'], df_encounters['DURATION_DAYS'], df_encounters['TOTAL_CLAIM_COST'], alpha=0.4)
ax.set_xlabel('Edad')
ax.set_ylabel('Duraci√≥n')
ax.set_zlabel('Costo Total')
plt.title('Distribuci√≥n 3D: Edad, Duraci√≥n y Costo')
plt.tight_layout()
plt.show()

"""#### üìå Scatter 3D: Visualizaci√≥n de Edad, Duraci√≥n y Costo

El gr√°fico tridimensional permite **visualizar c√≥mo interact√∫an simult√°neamente las tres variables num√©ricas clave** del an√°lisis.

**üîçHallazgos visuales:**
- Se observa una **nube de puntos centralizada**, con aglomeraciones alrededor de pacientes entre 40 y 70 a√±os, duraci√≥n entre 0 y 2 d√≠as, y costos entre 500 d√≥lares y 5,000 d√≥lares.
- Hay **outliers que se elevan verticalmente** (alto costo), lo que sugiere procedimientos muy costosos aunque de corta duraci√≥n (ej. cirug√≠a ambulatoria costosa).
- Tambi√©n se observan algunos encuentros **largos y de alto costo**, lo que puede indicar hospitalizaciones complejas.

#### üß™ Detecci√≥n de Outliers con el M√©todo del IQR
"""

# Funci√≥n para detectar y mostrar outliers usando el m√©todo IQR
def detectar_outliers_iqr(df, columna):
    Q1 = df[columna].quantile(0.25)
    Q3 = df[columna].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    outliers = df[(df[columna] < lower_bound) | (df[columna] > upper_bound)]

    print(f'üìå Variable: {columna}')
    print(f'Q1: {Q1:.2f} | Q3: {Q3:.2f} | IQR: {IQR:.2f}')
    print(f'Limites: [{lower_bound:.2f}, {upper_bound:.2f}]')
    print(f'Total de outliers detectados: {outliers.shape[0]} ({100 * outliers.shape[0] / df.shape[0]:.2f}%)\n')

    return outliers

# Aplicamos a las tres variables principales
outliers_cost = detectar_outliers_iqr(df_encounters, 'TOTAL_CLAIM_COST')
outliers_duracion = detectar_outliers_iqr(df_encounters, 'DURATION_DAYS')
outliers_edad = detectar_outliers_iqr(df_encounters, 'AGE')

# Visualizaci√≥n de Boxplots con Outliers

fig, axs = plt.subplots(1, 3, figsize=(16, 5))

sns.boxplot(data=df_encounters, y='TOTAL_CLAIM_COST', ax=axs[0], color='skyblue')
axs[0].set_title('Outliers: Costo Total')

sns.boxplot(data=df_encounters, y='DURATION_DAYS', ax=axs[1], color='salmon')
axs[1].set_title('Outliers: Duraci√≥n del Encuentro')

sns.boxplot(data=df_encounters, y='AGE', ax=axs[2], color='lightgreen')
axs[2].set_title('Outliers: Edad del Paciente')

plt.tight_layout()
plt.show()

"""#### üìå An√°lisis de Outliers en Variables Clave

Se utiliz√≥ el m√©todo de **Rango Intercuart√≠lico (IQR)** para identificar valores at√≠picos en las variables num√©ricas m√°s relevantes.

**‚úÖ1. TOTAL_CLAIM_COST:**
- Se detectaron outliers con valores superiores a [Q3 + 1.5√óIQR].
- Algunos costos superan los **$50,000**, lo cual es raro pero posible cl√≠nicamente (cirug√≠as mayores, tratamientos oncol√≥gicos).
- Decisi√≥n: **No eliminar**, pero visualizarlos por separado o usar escala logar√≠tmica en algunos gr√°ficos.

**‚úÖ2. DURATION_DAYS:**
- Encuentros que superan los **15-20 d√≠as** son considerados at√≠picos.
- Decisi√≥n: **Mantener**, ya que representan internaciones prolongadas, pero incluir advertencias en los an√°lisis.

**‚úÖ3. AGE:**
- No se detectaron outliers extremos.
- La mayor√≠a de los pacientes est√°n en el rango de **20 a 90 a√±os**. Fuera de eso, se revis√≥ y no hay edades il√≥gicas.

**üìùConclusi√≥n:**
- **Los outliers son cl√≠nicamente posibles y relevantes** para el an√°lisis hospitalario.
- Se decidi√≥ **mantenerlos en el dataset**, pero controlarlos visualmente cuando sea necesario.

# üìÇ Conclusiones del An√°lisis Exploratorio de Datos (EDA)

Durante el an√°lisis exploratorio del dataset **Hospital + Patient + Records**, se realiz√≥ una revisi√≥n exhaustiva de las variables num√©ricas y categ√≥ricas, as√≠ como su interacci√≥n a trav√©s de an√°lisis univariado, bivariado, multivariado, temporal y geogr√°fico.

Se aplicaron t√©cnicas estad√≠sticas, visualizaciones y detecci√≥n de outliers utilizando Python, con el fin de identificar patrones, relaciones y comportamientos an√≥malos en los datos cl√≠nicos y administrativos del hospital.

#### **üìä Hallazgos Relevantes**


**üîπ Variables Num√©ricas**

   * ***Edad de los pacientes (AGE):*** Rango t√≠pico entre 20 y 90 a√±os. Mayor concentraci√≥n entre 40 y 70.

   * ***Duraci√≥n del encuentro (DURATION_DAYS):*** La mayor√≠a de los encuentros duran menos de 2 d√≠as, pero hay outliers que superan los 15 d√≠as.

   * ***Costo total del encuentro (TOTAL_CLAIM_COST):*** Distribuci√≥n sesgada positivamente; muchos encuentros cuestan entre 500 d√≥lares y 5,000 d√≥lares, pero existen casos que superan los 50,000 d√≥lares.


**üîπ Variables Categ√≥ricas**

   * ***G√©nero (GENDER):*** Distribuci√≥n casi equitativa entre hombres (50.7%) y mujeres (49.3%).

   * ***Estado civil, raza y etnia:*** Predominio de pacientes casados, de raza blanca y sin datos espec√≠ficos de etnicidad en algunos casos.

   * ***Tipo de encuentro (ENCOUNTERCLASS):*** Los encuentros ambulatorios y externos representan el mayor volumen, pero los hospitalarios son los de mayor duraci√≥n y costo.


#### **üìà Insights Significativos**



1.   No existe una correlaci√≥n fuerte entre edad y costos m√©dicos, pero s√≠ hay una relaci√≥n moderada entre la duraci√≥n del encuentro y el costo total.

2.   Algunas aseguradoras concentran procedimientos m√°s costosos y de mayor duraci√≥n, lo cual podr√≠a impactar la rentabilidad del hospital.

3.   La mayor√≠a de los encuentros se deben a enfermedades cr√≥nicas no transmisibles como hipertensi√≥n y diabetes.

4.   Pacientes mayores tienen mayor tendencia a hospitalizaci√≥n e internaci√≥n prolongada, aumentando el gasto cl√≠nico.

5.   Los picos de gasto mensual no son constantes, pero existen en ciertos periodos del a√±o, lo que sugiere una posible estacionalidad o demanda puntual.

6.   La mayor√≠a de los pacientes provienen de un grupo limitado de estados y ciudades, lo cual puede tener implicancias log√≠sticas y estrat√©gicas.



#### **üö® Outliers Detectados**

- Costos extremadamente altos (> $50,000)
- Duraciones muy largas (> 20 d√≠as)
- Algunos pacientes con m√∫ltiples procedimientos de alto impacto en un solo encuentro

Se decidi√≥ mantener los outliers por su posible validez cl√≠nica, pero monitorearlos visual y estad√≠sticamente en an√°lisis posteriores.


#### **üí° Recomendaciones para el Hospital**

1. Monitorear aseguradoras con mayor costo promedio por procedimiento y revisar acuerdos contractuales.

2. Auditar encuentros de duraci√≥n at√≠pica o de alto costo para prevenir sobrecostos injustificados.

3. Implementar alertas cl√≠nicas para pacientes mayores con alto riesgo de hospitalizaci√≥n.

4. Dise√±ar campa√±as preventivas y programas de control para enfermedades cr√≥nicas prevalentes.

5. Reforzar presencia operativa en los estados con mayor concentraci√≥n de pacientes.

6. Establecer un sistema de codificaci√≥n m√°s robusto para los motivos de consulta (REASONDESCRIPTION) para reducir la tasa de datos faltantes (hoy en m√°s del 70%).

# **‚úÖ AN√ÅLISIS TEMPORAL Y GEOGR√ÅFICO**

***üî∂üî∂ AN√ÅLISIS TEMPORAL***
"""

# üîç Variable: An√°lisis N√∫mero de Encuentros por A√±o

# Extraer a√±o y mes
df_encounters['YEAR'] = df_encounters['START'].dt.year
df_encounters['MONTH'] = df_encounters['START'].dt.month

# Encuentros por a√±o
year_counts = df_encounters['YEAR'].value_counts().sort_index()

# Gr√°fico
plt.figure(figsize=(10, 5))
sns.lineplot(x=year_counts.index, y=year_counts.values, marker='o')
plt.title('N√∫mero de Encuentros por A√±o')
plt.xlabel('A√±o')
plt.ylabel('Cantidad de Encuentros')
plt.tight_layout()
plt.show()

"""#### üìå Evoluci√≥n del N√∫mero de Encuentros M√©dicos por A√±o

El gr√°fico muestra la cantidad de encuentros m√©dicos registrados por a√±o entre 2011 y 2022.

**üîçHallazgos:**
- Se observa un crecimiento sostenido entre 2011 y 2014, alcanzando el m√°ximo en 2014.

- A partir de 2015 hasta 2019, se presenta una tendencia a la baja, con una reducci√≥n progresiva en la cantidad de encuentros.

- En 2020 y 2021, se observa una recuperaci√≥n importante, posiblemente tras la primera fase de la pandemia.

- En 2022, se registra una ca√≠da abrupta, probablemente relacionada con un corte en la recolecci√≥n de datos y no con una disminuci√≥n real en la actividad m√©dica.

**‚úçÔ∏èRecomendaci√≥n:**
- El hospital o sistema de salud debe estar preparado para fluctuaciones en la demanda, especialmente en situaciones externas como pandemias.

- Se sugiere investigar el motivo del descenso sostenido entre 2015 y 2019, as√≠ como confirmar si el dato de 2022 est√° completo o requiere revisi√≥n.

"""

# üîç Variable: An√°lisis Costo Total por Mes (para detectar estacionalidad)

## Evoluci√≥n del Costo Total de Encuentros por Mes (con Promedio M√≥vil)

# Asegurarse de que la fecha est√© en formato datetime
df_encounters['START'] = pd.to_datetime(df_encounters['START'])

# Crear columna YEAR_MONTH en formato 'YYYY-MM'
df_encounters['START'] = df_encounters['START'].dt.tz_localize(None)
df_encounters['YEAR_MONTH'] = df_encounters['START'].dt.to_period('M').astype(str)

# Agrupar y sumar el costo total por mes
monthly_cost = df_encounters.groupby('YEAR_MONTH')['TOTAL_CLAIM_COST'].sum()

# Crear promedio m√≥vil de 3 meses
monthly_cost_rolling = monthly_cost.rolling(window=3).mean()

# Gr√°fico
plt.figure(figsize=(14, 6))
plt.plot(monthly_cost.index, monthly_cost.values, label='Costo Total Mensual', marker='o')
plt.plot(monthly_cost.index, monthly_cost_rolling, label='Promedio M√≥vil (3 meses)', linestyle='--', linewidth=2)
plt.title('Evoluci√≥n del Costo Total de Encuentros por Mes (con Promedio M√≥vil)')
plt.xlabel('Fecha (A√±o-Mes)')
plt.ylabel('Costo Total ($)')
plt.xticks(rotation=45)
plt.legend()
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""#### üìå Evoluci√≥n del Costo Total de Encuentros por Mes (con Promedio M√≥vil)

El gr√°fico presenta la evoluci√≥n mensual del costo total de los encuentros m√©dicos, desde el inicio del registro hasta la fecha m√°s reciente.

**üîçHallazgos:**

  - *Tendencia General Estable:* A lo largo del per√≠odo, el costo total mensual se mantiene relativamente estable, con ligeras variaciones y una tendencia moderadamente creciente en los √∫ltimos a√±os.

  - *Pico Irregular Significativo:* Se observa un pico excepcional en un mes puntual, con un valor superior a los $500.000, lo cual rompe el patr√≥n normal y afecta moment√°neamente la curva de tendencia. Este valor debe ser investigado, ya que puede deberse a:

    * Un procedimiento m√©dico de alt√≠simo costo,

    * Un error de carga o duplicaci√≥n de datos,

    * Un evento extraordinario (ej.: subsidios o campa√±as masivas).

  - *Ca√≠da Abrupta Reciente:* En los √∫ltimos meses se presenta una disminuci√≥n dr√°stica del costo total, lo cual probablemente no refleja una disminuci√≥n real, sino que indica datos incompletos o un corte en la carga de informaci√≥n reciente.

***üî∂üî∂ AN√ÅLISIS GEOGR√ÅFICO***
"""

# üîç Variable: An√°lisis Distribuci√≥n de Pacientes por Condado

# Obtener los 10 condados con m√°s pacientes
county_counts = df_patients['COUNTY'].value_counts().head(10)

# Gr√°fico
plt.figure(figsize=(10, 5))
ax = sns.barplot(
    x=county_counts.index,
    y=county_counts.values,
    hue=county_counts.index,
    palette='viridis',
    legend=False
)

# Agregar etiquetas de cantidad sobre cada barra
for i, value in enumerate(county_counts.values):
    ax.text(i, value + 5, str(value), ha='center', va='bottom', fontsize=9)

plt.title('Top 10 Condados por Cantidad de Pacientes')
plt.xlabel('Condado')
plt.ylabel('Cantidad de Pacientes')
plt.tight_layout()
plt.show()

"""#### üìç Distribuci√≥n de Pacientes por Condado

El an√°lisis muestra la distribuci√≥n geogr√°fica de los pacientes seg√∫n su condado de residencia, permitiendo identificar √°reas clave de influencia para el hospital.

**üß† Hallazgos destacados:**

- El Condado de Suffolk concentra la mayor√≠a de los pacientes (644 registros), representando por s√≠ solo m√°s del 60% de la base de pacientes analizada.
- Condados como Plymouth y Essex tienen una participaci√≥n muy baja en el total, con solo 49 y 1 pacientes respectivamente.

**‚ú®Insight:**
- Existe una concentraci√≥n geogr√°fica evidente, lo que sugiere que el hospital tiene una presencia territorial fuerte en uno o pocos condados.
- La dependencia excesiva de una sola regi√≥n podr√≠a representar una vulnerabilidad o una oportunidad de expansi√≥n hacia otras zonas.

**‚úçÔ∏èRecomendaci√≥n:**
- Reforzar la cobertura y los servicios ofrecidos en el Condado de Suffolk, ya que representa la base principal de pacientes.
- Analizar el perfil de pacientes en los condados de menor participaci√≥n para identificar barreras (distancia, falta de convenios, poca promoci√≥n).
- Explorar la expansi√≥n de servicios o marketing en condados cercanos como Norfolk y Middlesex, que ya presentan una base moderada y podr√≠an crecer.
- Monitorear tendencias geogr√°ficas con el tiempo para anticipar cambios en la demanda por regi√≥n.

"""

# üîç Variable: An√°lisis Distribuci√≥n por Ciudad

# Obtener las 10 ciudades con m√°s pacientes
city_counts = df_patients['CITY'].value_counts().head(10)

plt.figure(figsize=(10, 5))
ax = sns.barplot(
    x=city_counts.index,
    y=city_counts.values,
    hue=city_counts.index,
    palette='magma',
    legend=False
)

# Agregar etiquetas con los valores encima de cada barra
for i, value in enumerate(city_counts.values):
    ax.text(i, value + 5, str(value), ha='center', va='bottom', fontsize=9)

plt.title('Top 10 Ciudades por N√∫mero de Pacientes')
plt.xlabel('Ciudad')
plt.ylabel('Cantidad de Pacientes')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""#### üèôÔ∏è Distribuci√≥n de Pacientes por Ciudad

Este gr√°fico presenta las 10 ciudades con mayor n√∫mero de pacientes registrados en el hospital, permitiendo analizar la presencia urbana y las oportunidades de expansi√≥n territorial.

**üß† Hallazgos Clave:**

- Boston concentra de forma contundente la mayor√≠a de los pacientes (541 personas), representando m√°s del 50% del total.
- Las √∫ltimas ciudades del top 10 tienen menos de 25 pacientes, lo cual muestra una gran asimetr√≠a en la distribuci√≥n geogr√°fica urbana.

**‚ú® Insight:**

- El hospital tiene una fuerte concentraci√≥n de pacientes en la ciudad de Boston, lo que probablemente coincide con su ubicaci√≥n f√≠sica principal.
- El resto de las ciudades presentan una base de pacientes significativamente menor, lo que podr√≠a reflejar falta de alcance, promoci√≥n o convenios locales.

**‚úçÔ∏è Recomendaciones para el hospital:**

- Consolidar la presencia en Boston, asegurando cobertura m√©dica eficiente y r√°pida atenci√≥n para la mayor√≠a de su poblaci√≥n atendida.
- Evaluar estrategias de marketing, alianzas o extensi√≥n de servicios en ciudades cercanas como Quincy, Cambridge y Revere, donde ya existe una base moderada de pacientes.
- Investigar las causas de baja participaci√≥n en otras ciudades (por ejemplo, accesibilidad, transporte, preferencia por otros centros de salud).

# **‚úÖ MODELO PREDICTIVO**

***üî∂üî∂ M√âTODO DE REGRESI√ìN LINEAL***

# Regresi√≥n del Costo M√©dico

## üéØ Objetivo

- Predecir el costo total del encuentro m√©dico (`TOTAL_CLAIM_COST`) a partir de caracter√≠sticas del paciente, del encuentro y de la aseguradora.
"""

# ‚úÖ Paso 1: Selecci√≥n y preparaci√≥n de variables

# Copia del df_encounters
df_model = df_encounters.copy()

# Agregar el nombre de la aseguradora (merge con df_payers)
df_model = df_model.merge(df_payers[['Id', 'NAME']], left_on='PAYER', right_on='Id', how='left')
df_model.rename(columns={'NAME': 'PAYER_NAME'}, inplace=True)

# Seleccionamos variables de inter√©s
variables = ['AGE', 'DURATION_DAYS', 'ENCOUNTERCLASS', 'PAYER_NAME']

# Filtramos columnas necesarias + target
df_model = df_model[variables + ['TOTAL_CLAIM_COST']].dropna()

# One-Hot Encoding para variables categ√≥ricas
df_model_encoded = pd.get_dummies(df_model, columns=['ENCOUNTERCLASS', 'PAYER_NAME'], drop_first=True)

# Separar X e y
X = df_model_encoded.drop('TOTAL_CLAIM_COST', axis=1)
y = df_model_encoded['TOTAL_CLAIM_COST']

# ‚úÖ Paso 2: Divisi√≥n de datos de entrenamiento y prueba

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)



# ‚úÖ Paso 3: Modelo de Regresi√≥n Lineal

# Modelo
modelo = LinearRegression()
modelo.fit(X_train, y_train)

# Predicciones
y_pred = modelo.predict(X_test)

# Evaluaci√≥n
r2 = r2_score(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)

print(f"üìä R¬≤ (coef. determinaci√≥n): {r2:.2f}")
print(f"üìâ MSE (error cuadr√°tico medio): {mse:.2f}")



# ‚úÖ Paso 4 : Predicciones ordenadas (gr√°fico de l√≠nea)

# Ordenar por costo real
orden = np.argsort(y_test.values)
y_real_ordenado = y_test.values[orden]
y_pred_ordenado = y_pred[orden]

plt.figure(figsize=(10, 5))
plt.plot(y_real_ordenado, label='Costo Real')
plt.plot(y_pred_ordenado, label='Costo Predicho')
plt.title('Comparaci√≥n de Costos Reales vs Predichos')
plt.xlabel('Pacientes ordenados por costo real')
plt.ylabel('Costo del Encuentro ($)')
plt.legend()
plt.tight_layout()
plt.show()

"""### üìä Interpretaci√≥n del Modelo de Regresi√≥n Lineal: Predicci√≥n del Costo Total del Encuentro

#### ‚öôÔ∏è Caracter√≠sticas del modelo:
- Se utiliz√≥ **Regresi√≥n Lineal** como modelo base, por su interpretabilidad.
- Las variables categ√≥ricas (`ENCOUNTERCLASS` y `PAYER_NAME`) fueron transformadas con codificaci√≥n *one-hot*.
- El conjunto de datos fue dividido en 80% entrenamiento y 20% prueba para evitar sobreajuste.

#### üìà Resultados obtenidos:
- **R¬≤ (coeficiente de determinaci√≥n)**: `0.14`. El modelo solo explica el 14% de la variabilidad en los costos, lo que indica un bajo poder predictivo. Esto sugiere que existen otros factores no contemplados que influyen significativamente en el costo m√©dico.
- **MSE (error cuadr√°tico medio)**: `$230,858.13`. Un error cuadr√°tico medio elevado indica que, en promedio, las predicciones difieren notablemente de los costos reales. Esto se agrava en los casos de costos extremos o encuentros hospitalarios prolongados.

#### üìâ An√°lisis del gr√°fico:
La gr√°fica muestra:

- Una l√≠nea azul que representa el costo real, ordenado de menor a mayor (se puede ver una curva creciente clara).
- Una l√≠nea naranja (irregular y plana), que representa el costo predicho, la cual oscila sin seguir la forma real del costo.

Esto indica que:

- El modelo predice un rango estrecho y constante de costos, sin adaptarse bien a valores bajos ni altos.
- No capta bien los outliers, ni las diferencias reales en funci√≥n de duraci√≥n, tipo de encuentro o aseguradora.
- El modelo subestima severamente los costos m√°s altos y no distingue entre pacientes de bajo o alto costo.

Causas posibles:

- Uso de un modelo lineal en un problema probablemente no lineal.
- Falta de variables relevantes: no se incluyeron procedimientos, organizaci√≥n, motivo del encuentro, etc.
- Alta presencia de outliers y distribuci√≥n sesgada del costo m√©dico.

#### ‚úÖ Recomendaciones al hospital:
- Usar este modelo como base para **estimar costos** de nuevos pacientes de forma anticipada.
- **Monitorear aseguradoras** que sistem√°ticamente se asocian a costos elevados.
- Implementar herramientas autom√°ticas de predicci√≥n de costos para **gesti√≥n financiera, auditor√≠a y prevenci√≥n de sobrecostos**.

# üßæ **CONCLUSI√ìN FINAL DEL PROYECTO**

Este proyecto ha representado un ejercicio integral de an√°lisis de datos aplicado al sector hospitalario, abarcando todas las fases de un proceso anal√≠tico profesional: desde la exploraci√≥n y limpieza de datos, hasta la construcci√≥n de modelos predictivos y la generaci√≥n de recomendaciones accionables.


## üìå **Resumen General del An√°lisis**
- Se integraron m√∫ltiples fuentes de datos relacionados con pacientes, procedimientos, aseguradoras, organizaciones y encuentros m√©dicos.
- Se realiz√≥ una **limpieza exhaustiva**, detectando y tratando valores nulos, formatos inconsistentes y outliers cl√≠nicos y financieros.
- El an√°lisis exploratorio (EDA) revel√≥ **patrones importantes** sobre la duraci√≥n, costo y causas de los encuentros m√©dicos, con insights diferenciados por aseguradora, tipo de encuentro y ubicaci√≥n geogr√°fica.
- Se construy√≥ un modelo de **regresi√≥n lineal** con variables enriquecidas. Aunque el R¬≤ fue bajo, el modelo ayud√≥ a evidenciar qu√© factores m√°s afectan los costos.
- Se aplicaron an√°lisis bivariados y multivariados para descubrir **asociaciones entre edad, duraci√≥n, costo, tipo de procedimiento y geograf√≠a**.

## üîç **Hallazgos M√°s Relevantes**
- El **tipo de encuentro** y la **aseguradora** son los principales impulsores del costo m√©dico.
- Existen procedimientos altamente costosos con duraci√≥n breve, lo que indica que **el tipo de tratamiento importa m√°s que la duraci√≥n en muchos casos**.
- La mayor√≠a de los pacientes se concentran en ciertos condados y ciudades, y los costos var√≠an significativamente seg√∫n la regi√≥n.
- Algunas aseguradoras, como *PAYER_7caa...*, cubren procedimientos de mayor costo en promedio, lo cual tiene implicancias administrativas y financieras importantes para el hospital.

## üí° **Insights y Recomendaciones al Hospital**
1. **Monitorear de cerca los procedimientos de alto costo**, especialmente los que aparecen repetidamente en las aseguradoras m√°s caras.
2. **Establecer pol√≠ticas diferenciadas por aseguradora**, basadas en patrones de uso y costos promedios.
3. **Reducir la duraci√≥n innecesaria de internaciones**, sin afectar la calidad de atenci√≥n, podr√≠a generar un ahorro considerable.
4. **Ampliar la capacidad anal√≠tica del hospital**, incorporando nuevas fuentes de datos cl√≠nicos y desarrollando modelos m√°s robustos (√°rboles de decisi√≥n, clustering, etc.).
5. **Monitorear estacionalidad y picos de demanda por mes**, para optimizar recursos humanos y materiales.



---

## ‚úÖ Checklist Final del Proyecto

- [x] Carga de datos
- [x] Limpieza y transformaci√≥n
- [x] EDA completo (uni, bi, multivariado)
- [x] An√°lisis temporal y geogr√°fico
- [x] Respuesta a preguntas clave de negocio
- [x] Modelo de regresi√≥n y evaluaci√≥n
- [x] Insights y recomendaciones
- [x] Integraci√≥n de variables desde m√∫ltiples datasets
- [x] Gr√°ficos con interpretaciones
- [x] Notebook limpio, estructurado y documentado
- [x] Conclusi√≥n Final

---

**üîó Dashboard en Power BI:** *Disponible para consulta con las visualizaciones finales e interactivas del an√°lisis.
"""